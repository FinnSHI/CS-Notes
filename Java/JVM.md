# JVM

## 自动内存管理

### 1 概述

### 2 内存区域

#### 2.1 运行时内存区域

![image-20220125101616135](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202201251016250.png)

##### 2.1.1 程序计数器

- 线程**私有**：每个线程拥有独立的程序计数器，且互不影响。

- 当前线程所执行的字节码的行号指示器。

- 字节码解释器工作时，就是通过改变**程序计数器**来选取下一条要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等等）。

  

##### 2.1.2 Java虚拟机栈

- 线程**私有**
- 描述Java方法（字节码）内存模型
  - Java方法执行时，Java虚拟机创建 **stack frame**（存储局部变量表、操作数栈、动态连接、方法出口等信息）
  - 方法执行过是 stack frame 在虚拟机栈中入栈和出栈的过程

- 两个异常：
  - StackOverFlow：线程请求的栈深度超过了虚拟机栈所允许的深度
  - OutOfMemoryError：如果虚拟机栈容量可以动态扩展，栈扩展时无法申请到更多的内存。



##### 2.1.3 本地方法栈

- 和虚拟机栈类似，只是是为的是本地（native）方法服务的。



##### 2.1.4 堆

- 线程**共享**
- 虚拟机启动时创建，存放对象实例
- 线程有私有的缓冲区来提高获取对象实例的效率
- 堆是由GC管理的内存区域



##### 2.1.5 方法区

- 线程**共享**
- 存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。



方法区：

1）运行时常量池：字面量和符号引用



#### 2.2 对象（普通Java对象）

##### 2.2.1 (⭐)对象的创建

![image-20220205143228626](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051432679.png)

1. 确定类加载：在常量池中定位符号引用，然后定位到类，检查该类有没有被加载、解析和初始化过

2. 在Java堆中划分内存，

   - **指针碰撞：**如果Java堆中内存是绝对规整的，

     - 所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，
     - 分配内存就仅仅是把<u>那个指针向空闲空间方向挪动一段与对象大小相等的距离</u>。	

   - **空闲列表：**如果Java堆中的内存不是规整的

     - 虚拟机就必须维护一个列表，记录上哪些内存块是可用的，
     - 在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

     

     对象创建是个很频繁的活动，因此需要解决分配空间时的线程安全问题：

     1）**CAS+失败重试**：CAS是乐观锁的实现方式。<u>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性</u>

     > 乐观锁和悲观锁是两种思想，为了解决并发场景下数据竞争的问题
     >
     > - 乐观锁：不会上锁。因为认为别人不会同时修改操作，执行更新操作的时候，判断下此期间是否有人修改操作，如果有，则放弃更新。
     >
     >   乐观锁实现方式：
     >
     >   - **CAS**：Compare and Swap：如果内存空间 valueOffset 等于预期的值A，则将该位置值更新成值B，否则不进行操作。
     >
     >     CAS是CPU支持的原子操作。在硬件层面保证原子性。
     >
     >     > CAS的缺点：
     >     >
     >     > ABA问题
     >     >
     >     > 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：
     >     >
     >     > (1)线程1读取内存中数据为A；
     >     >
     >     > (2)线程2将该数据修改为B；
     >     >
     >     > (3)线程2将该数据修改为A；
     >     >
     >     > (4)线程1对数据进行CAS操作
     >     >
     >     > 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。
     >     >
     >     > 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
     >     >
     >     > 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。
     >
     >   - **版本号机制**：数据增加版本号字段，数据每更新一次，版本号加一
     >
     > - 悲观锁：上锁，需要额外的资源。线程在对数据进行操作时，会添加排他锁，要是其他线程想要操作该数据，则会被堵塞。

     2）**本地线程分配缓冲（TLAB）：**哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完

     了，分配新的缓存区时才需要同步锁定。

3. 初始化零值：
   - 将分配到的内存空间（但不包括对象头）都初始化为零值。
   - 如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。
   - 这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。

   - 对象属于哪个类

   - 怎么找到类的元数据信息

     > 元数据：Data that describes other data

   - 对象哈希码（延后到真正调用Object::hashCode()方法时才计算）

   - 对象的GC分代年龄

5. 执行 `<init>` 方法。
   - 构造函数，对象初始化



##### 2.2.2 对象布局

1. 对象头 Header，包括两类信息

   - 存储对象自身的运行时数据
     - 哈希码
     - GC分代年龄
     - 锁状态标志
     - 线程持有的锁
     - 偏向线程ID
     - 偏向时间戳
   - 类型指针：即对象指向它的类型元数据的指针。
     - Java虚拟机通过这个指针来确定该对象是哪个类的实例
     - 但是查找对象的元数据信息并不一定要经过对象本身
     - 如果对象是数组，则还保存了数组的长度信息

2. 实例数据 Instance Data

   - 对象在代码里面所定义的各种类型的字段内容

   - HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，

     OOPs）

3. 对齐填充 padding

   - HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是<u>8字节的整数倍</u>
   - 对象头已经是8字节的整数倍
   - 通过 padding 来使对象的内存大小为8字节的整数倍



##### 2.2.3 对象访问

Java程序通过栈上reference数据来操作堆上的具体对象实例。

有两种方式：

- 方式一：句柄访问

  - reference数据存储句柄
  - 好处：对象移动时（如被回收），只需改变实例数据的指针，reference本身不用动

  ![image-20220205144044306](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051440383.png)

- 方式二：直接指针访问

  - reference 存储
  - 好处：访问速度快

  ![image-20220205145323781](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051453861.png)









### 3 垃圾收集器与内存分配策略

#### 3.1 确定已死对象

##### 3.1.1 引用计数算法

对象中添加引用计数器，当有一个地方引用该对象时，计数器+1；引用失效时，计数器-1。

该方法有问题，比如：

```
ReferenceCountingGC objA = new ReferenceCountingGC();
ReferenceCountingGC objB = new ReferenceCountingGC();
objA.instance = objB; // objA引用计数器+1
objB.instance = objA; // objB引用计数器+1

objA = null;
objB = null;
// 假设在这行发生GC，objA和objB是否能被回收？
System.gc(); //不能，objA和objB引用计数器不为0，但实际上这两个对象已死
```

Java并没有使用这个方法。



##### 3.1.2 可达性分析算法

> “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference  Chain）。如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![image-20220205151101315](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051511378.png)



- 可固定作为GC Roots的对象：

  - **虚拟机栈中引用的对象**。

    如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

  - **方法区中静态属性引用的对象**。如引用类型静态变量。

  - **方法区中常量属性引用的对象**。如String常量池中的引用。

  - **本地方法栈中 Native 方法引用的对象**

  - **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象

    比如NullPointExcepiton、OutOfMemoryError等，还有系统类加载器

  - **所有被同步锁持有的对象**

  - **反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等**。

  - **其他对象“临时性”地加入**。

    譬如分代收集和局部回收（Partial GC），



##### 3.1.3 引用

强度：强引用 > 软引用 >弱引用 > 虚引用 

- 强引用：引用赋值。对象强引用关系存在时，GC永远不会回收该对象。

  ```
  Object obj = new Object(); //强引用
  ```

  

- 软引用：可以用，但不必要。

  ​				内存溢出异常前，先对这些对象进行第二次回收，如果内存仍不足，则抛出内存溢出异常。

- 弱引用：不必要的内存。弱引用的对象只存活到下一次GC工作前。下一次GC回收对象时，会回收掉弱引用的对象。

- 虚引用：虚引用对对象生存时间不构成任何影响，也不能通过虚引用取得对象实例，只是为了GC回收该对象时，获得一次系统通知。

  

##### 3.1.4 对象生存和死亡

对象至少经过两次标记后，才会被宣告死亡。

- <u>第一次标记</u>：通过 reference chain 不可达的对象
- 筛选对象是否有必要执行 finalize() 方法。
  - 没有必要
    - 虚拟机已经调用过该对象的finalize()方法
    - 或 该对象没有覆盖 finalize() 方法
- 有必要执行 finalize() 方法
  - 对象放入F-Queue队列中
  - 虚拟机创建一条低优先级的 Finalizer 线程去执行队列中对象的finalize()方法
    - Finalizer 线程只调用 finalize() 方法，但不保证会等待它运行结束。

- 如果对象调用 finalize() 方法后拯救了自己（重新和reference chain上的对象关联），那么就逃脱一死。
- <u>第二次标记</u>：对象调用 finalize() 方法后不能拯救自己，就被二次标记。

> 任何一个对象的finalize()方法都只会被系统自动调用一次





##### 3.1.5 回收方法区

- 回收废弃常量
  - 没有任何对象引用常量池中的某个常量，该常量就可以被清理。
- **允许**回收不再使用的类型（类）
  - 该类的实例都被回收
  - 该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

