# JVM

## 自动内存管理

### 1 概述

### 2 内存区域

#### 2.1 运行时内存区域

![image-20220125101616135](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202201251016250.png)

##### 2.1.1 程序计数器

- 线程**私有**：每个线程拥有独立的程序计数器，且互不影响。

- 当前线程所执行的字节码的行号指示器。

- 字节码解释器工作时，就是通过改变**程序计数器**来选取下一条要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等等）。

  

##### 2.1.2 Java虚拟机栈

- 线程**私有**
- 描述Java方法（字节码）内存模型
  - Java方法执行时，Java虚拟机创建 **stack frame**（存储局部变量表、操作数栈、动态连接、方法出口等信息）
  - 方法执行过是 stack frame 在虚拟机栈中入栈和出栈的过程

- 两个异常：
  - StackOverFlow：线程请求的栈深度超过了虚拟机栈所允许的深度
  - OutOfMemoryError：如果虚拟机栈容量可以动态扩展，栈扩展时无法申请到更多的内存。



##### 2.1.3 本地方法栈

- 和虚拟机栈类似，只是是为的是本地（native）方法服务的。



##### 2.1.4 堆

- 线程**共享**
- 虚拟机启动时创建，存放对象实例
- 线程有私有的缓冲区来提高获取对象实例的效率
- 堆是由GC管理的内存区域



##### 2.1.5 方法区

- 线程**共享**
- 存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。



方法区：

1）运行时常量池：字面量和符号引用



#### 2.2 对象（普通Java对象）

##### 2.2.1 (⭐)对象的创建

![image-20220205143228626](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051432679.png)

1. 确定类加载：在常量池中定位符号引用，然后定位到类，检查该类有没有被加载、解析和初始化过

2. 在Java堆中划分内存，

   - **指针碰撞：**如果Java堆中内存是绝对规整的，

     - 所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，
     - 分配内存就仅仅是把<u>那个指针向空闲空间方向挪动一段与对象大小相等的距离</u>。	

   - **空闲列表：**如果Java堆中的内存不是规整的

     - 虚拟机就必须维护一个列表，记录上哪些内存块是可用的，
     - 在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

     

     对象创建是个很频繁的活动，因此需要解决分配空间时的线程安全问题：

     1）**CAS+失败重试**：CAS是乐观锁的实现方式。<u>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性</u>

     > 乐观锁和悲观锁是两种思想，为了解决并发场景下数据竞争的问题
     >
     > - 乐观锁：不会上锁。因为认为别人不会同时修改操作，执行更新操作的时候，判断下此期间是否有人修改操作，如果有，则放弃更新。
     >
     >   乐观锁实现方式：
     >
     >   - **CAS**：Compare and Swap：如果内存空间 valueOffset 等于预期的值A，则将该位置值更新成值B，否则不进行操作。
     >
     >     CAS是CPU支持的原子操作。在硬件层面保证原子性。
     >
     >     > CAS的缺点：
     >     >
     >     > ABA问题
     >     >
     >     > 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：
     >     >
     >     > (1)线程1读取内存中数据为A；
     >     >
     >     > (2)线程2将该数据修改为B；
     >     >
     >     > (3)线程2将该数据修改为A；
     >     >
     >     > (4)线程1对数据进行CAS操作
     >     >
     >     > 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。
     >     >
     >     > 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
     >     >
     >     > 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。
     >
     >   - **版本号机制**：数据增加版本号字段，数据每更新一次，版本号加一
     >
     > - 悲观锁：上锁，需要额外的资源。线程在对数据进行操作时，会添加排他锁，要是其他线程想要操作该数据，则会被堵塞。

     2）**本地线程分配缓冲（TLAB）：**哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完

     了，分配新的缓存区时才需要同步锁定。

3. 初始化零值：
   - 将分配到的内存空间（但不包括对象头）都初始化为零值。
   - 如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。
   - 这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。

   - 对象属于哪个类

   - 怎么找到类的元数据信息

     > 元数据：Data that describes other data

   - 对象哈希码（延后到真正调用Object::hashCode()方法时才计算）

   - 对象的GC分代年龄

5. 执行 `<init>` 方法。
   - 构造函数，对象初始化



##### 2.2.2 对象布局

1. 对象头 Header，包括两类信息

   - 存储对象自身的运行时数据
     - 哈希码
     - GC分代年龄
     - 锁状态标志
     - 线程持有的锁
     - 偏向线程ID
     - 偏向时间戳
   - 类型指针：即对象指向它的类型元数据的指针。
     - Java虚拟机通过这个指针来确定该对象是哪个类的实例
     - 但是查找对象的元数据信息并不一定要经过对象本身
     - 如果对象是数组，则还保存了数组的长度信息

2. 实例数据 Instance Data

   - 对象在代码里面所定义的各种类型的字段内容

   - HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，

     OOPs）

3. 对齐填充 padding

   - HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是<u>8字节的整数倍</u>
   - 对象头已经是8字节的整数倍
   - 通过 padding 来使对象的内存大小为8字节的整数倍



##### 2.2.3 对象访问

Java程序通过**Java栈**上reference数据来操作**堆**上的具体<u>对象实例</u>。

有两种方式：

- 方式一：句柄访问

  - reference数据存储句柄
  - 好处：对象移动时（如被回收），只需改变实例数据的指针，reference本身不用动

  ![image-20220205144044306](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051440383.png)

- 方式二：直接指针访问

  - reference 存储
  - 好处：访问速度快

  ![image-20220205145323781](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051453861.png)









### 3 垃圾收集器与内存分配策略

#### 3.1 对象存活判定算法

##### 3.1.1 引用计数算法

对象中添加引用计数器，当有一个地方引用该对象时，计数器+1；引用失效时，计数器-1。

该方法有问题，比如：

```
ReferenceCountingGC objA = new ReferenceCountingGC();
ReferenceCountingGC objB = new ReferenceCountingGC();
objA.instance = objB; // objA引用计数器+1
objB.instance = objA; // objB引用计数器+1

objA = null;
objB = null;
// 假设在这行发生GC，objA和objB是否能被回收？
System.gc(); //不能，objA和objB引用计数器不为0，但实际上这两个对象已死
```

Java并没有使用这个方法。



##### 3.1.2 可达性分析算法

> “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference  Chain）。如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![image-20220205151101315](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051511378.png)



- 可固定作为GC Roots的对象：

  - **虚拟机栈中引用的对象**。

    如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

  - **方法区中静态属性引用的对象**。如引用类型静态变量。

  - **方法区中常量属性引用的对象**。如String常量池中的引用。

  - **本地方法栈中 Native 方法引用的对象**

  - **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象

    比如NullPointExcepiton、OutOfMemoryError等，还有系统类加载器

  - **所有被同步锁持有的对象**

  - **反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等**。

  - **其他对象“临时性”地加入**。

    譬如分代收集和局部回收（Partial GC），



##### 3.1.3 引用

强度：强引用 > 软引用 >弱引用 > 虚引用 

- 强引用：引用赋值。对象强引用关系存在时，GC永远不会回收该对象。

  ```
  Object obj = new Object(); //强引用
  ```

  

- 软引用：可以用，但不必要。

  ​				内存溢出异常前，先对这些对象进行第二次回收，如果内存仍不足，则抛出内存溢出异常。

- 弱引用：不必要的内存。弱引用的对象只存活到下一次GC工作前。下一次GC回收对象时，会回收掉弱引用的对象。

- 虚引用：虚引用对对象生存时间不构成任何影响，也不能通过虚引用取得对象实例，只是为了GC回收该对象时，获得一次系统通知。

  

##### 3.1.4 对象生存和死亡

对象至少经过两次标记后，才会被宣告死亡。

- <u>第一次标记</u>：通过 reference chain 不可达的对象
- 筛选对象是否有必要执行 finalize() 方法。
  - 没有必要
    - 虚拟机已经调用过该对象的finalize()方法
    - 或 该对象没有覆盖 finalize() 方法
- 有必要执行 finalize() 方法
  - 对象放入F-Queue队列中
  - 虚拟机创建一条低优先级的 Finalizer 线程去执行队列中对象的finalize()方法
    - Finalizer 线程只调用 finalize() 方法，但不保证会等待它运行结束。

- 如果对象调用 finalize() 方法后拯救了自己（重新和reference chain上的对象关联），那么就逃脱一死。
- <u>第二次标记</u>：对象调用 finalize() 方法后不能拯救自己，就被二次标记。

> 任何一个对象的finalize()方法都只会被系统自动调用一次





##### 3.1.5 回收方法区

- 回收废弃常量
  - 没有任何对象引用常量池中的某个常量，该常量就可以被清理。
- **允许**回收不再使用的类型（类）
  - 该类的实例都被回收
  - 该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。





#### 3.2 垃圾收集算法

> 分代收集理论
>
> - 弱分代假说：大多数对象都是朝生夕灭的
> - 强分代假说：熬过多次垃圾收集的对象，更加难以被消灭
> - 跨代引用假说：存在相互引用的两个对象，应该同时生存或者同时死亡
>
> 所以，Java堆中应该划分出多个区域，至少有个“新生代”区域集中朝生夕灭的对象，一个"老年代"区域放入难以回收的对象。
>
> 在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。
>
> 新生代上有个数据结构 “记忆集”，标识出老年代上存在跨代引用（老年代引用新生代对象）关系的对象。

- 整个Java堆 Full GC
  - 新生代 Minor GC
  - 老生代 Major GC



##### 3.2.1 标记-清除算法

1. 先标记出要回收的对象
2. 标记完清除对象。

- 缺点：
  - 效率低
  - 空间碎片化



##### 3.2.2 标记-复制算法

1. 内存中额外留下一片区域
2. 每当对象清除完，把剩下的对象复制到保留区域中。

![image-20220207145233806](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202071452936.png)

- 优点：
  - 空间连续
- 缺点：
  - 内存空间浪费
  - 存活对象多的时候，复制开销大



##### 3.2.3 标记-整理算法

标记后，并不直接清除对象，而是把存活对象移动到内存空间的一端，然后清除掉存活对象边界以外的对象。

- 缺点：
  - 移动对象复杂





#### 3.3 （先跳过，后面看）HotSpot 算法细节实现

3.3.1 根节点枚举

3.3.2 安全点

3.3.3 安全区域



##### 3.3.4 记忆集与卡表

1. 记忆集：一种抽象数据结构
   - 记录 非收集区域 指向 收集区域 的<u>指针集合</u>
2. 卡表 Card Table ：一种记忆集的具体实现
   - HotSpot用字节数组来实现，每个元素标识内存区域中一块特定大小的内存块——卡页
     - 卡页内存在跨代指针，则脏了，标识为1
     - 否则，标识为0



##### 3.3.5 写屏障

写屏障技术<u>维护卡表</u>

- 写前屏障：引用类型字段赋值前进行操作
- 写后屏障：引用类型字段赋值后进行操作

> 伪共享问题：
>
> ​	现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。

![image-20220210160656851](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202101606022.png)

- 如何避免伪共享问题？
  - 先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏



##### 3.3.6 并发的可达性分析

三色标记 (Tri-color Marking)

- 白色：对象未被垃圾收集器访问过
  - 可达性分析开始时，所有对象都是白色的
  - 可达性分析结束时，白色的对象即为不可达对象
- 黑色：<u>对象</u>及<u>对象所有的引用</u>已经被访问过。
- 灰色：对象已经被访问过，但至少有一个引用还没被扫描。



用户线程和垃圾回收器在并发期间两种情况

- 用户线程改变了引用，使原本要回收的垃圾错误标记成存活 —> 产生浮动垃圾，可以接受
- 用户线程改变了引用，使原本存活的垃圾错误改成消亡 —> 不可接受

对象消失的两个条件：

1. 赋值器插入一条或多条从黑色对象到白色对象的引用
   - 黑色对象已经是该对象和所有引用都访问过的对象了，所以新添加的引用不会被访问，于是产生了对象消失的问题。
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决办法：

- 增量更新：黑色对象新添引用到白色对象时，记录下新插入的引用记录，并发扫描结束后，从记录处以黑色对象为根，重新扫描一次。
- 原始快照：灰色对象要删除指向白色对象的引用关系时，将删除的引用记录下来，并发扫描结束后，将记录过的引用关系中灰色关系为根，重新扫描一次。



#### 3.4 经典垃圾收集器

![image-20220208145642953](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081456037.png)



- 并行 Parallel: 同一时间有多条垃圾收集器线程在工作，且默认用户工作线程是停止的
- 并发 Concurrent：垃圾收集器和用户线程都在运行。但是垃圾收集器占用了部分系统资源，因此应用程序的吞吐量受到影响。



- 吞吐量 = 运行用户代码时间 / （ 运行用户代码时间 + 运行垃圾收集时间）



##### 3.4.1 新生代收集器

1. ==**Serial**==

![image-20220208150630614](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081506677.png)

- 特点：
  - 新生代
  - 单线程
    - 使用一条收集线程去回收对象
    - 垃圾收集时，会暂停其他的工作线程
- 优点：
  - 简单高效
  - 额外内存消耗最小

- 缺点：
  - 会停掉用户正常的工作线程



2. ==**ParNew**==

 ![image-20220208150735709](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081507777.png)

Serial 收集器多线程并行版本



3. ##### ==Parallel Scavenge==

- 特点：

  - 新生代收集器
  - 基于标记-复制
  - 尽可能地控制吞吐量
    - 吞吐量 = 运行用户代码时间 / （ 运行用户代码时间 + 运行垃圾收集时间）
  - 两个参数
    - -XX： **MaxGCPauseMillis** 最大垃圾停顿时间。牺牲吞吐量和新生代内存大小实现的
    - -XX：**GCTimeRatio** 直接设置吞吐量大小。

  - -XX：UseAdaptiveSivePolicy 自适应调节吞吐量



##### 3.4.2 老年代收集器

1. ==**Serial Old**==

- 特点：

  - 标记-整理

  ![image-20220209193150187](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202091931282.png)



2. ==**Parallel Old**==

![image-20220209195527667](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202091957314.png)

- 特点：
  - 支持多线程并发
  - 标记-整理
  - 可以和 Parallel Scavenge 收集器搭配实现吞吐量优先收集器 



3. ==**CMS收集器**== (Concurrent Mark Sweep)

![image-20220209215127169](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202092151245.png)

- 特点：
  - 以获取<u>最短的回收停顿时间</u>为目标收集器
  - <u>对</u><u>处理器资源敏感</u>（因为是并发操作，并发执行的程序对处理器资源都很敏感）
    - GMS进行垃圾回收时，会占用部分资源，导致用户执行程序变慢，吞吐量降低。
  - 需要<u>预留足够内存空间</u>供用户线程，因此不能等到老年代区满了以后再回收垃圾，而是要在老年代区域中预留内存空间。
    - 如果并发过程中，出现内存不够的情况，就会出现“并发失败”问题
      - 预留方案：冻结用户线程，临时启动Serial Old老年代垃圾回收器。
- 步骤：
  1. **初始标记**：
     - 需要Stop the world （暂停用户线程）
     - 仅仅标记GC Roots能够直接关联的对象
  2. **并发标记**
     - 从GC Roots开始遍历整个对象图
  3. **重新标记**
     - 修正并发标记期间，因为用户线程继续运作而产生变动的对象的标记记录
  4. **并发清除**
     - 清除死亡对象
     - 不移动存活对象

-  缺点：

  - 无法处理“浮动垃圾”

    > 浮动垃圾：
    >
    > 本次垃圾回收中，用户线程在并发执行期间新产生的垃圾，需要等待下次垃圾回收时才能回收。

  - 标记-清除算法，会产生空间碎片。



> 如何保证垃圾收集线程和用户工作线程互不干扰？
>
> - 增量更新算法



##### 3.4.3 G1 

Garbage First

- 特点：

  - Mixed GC模式：
    - 不区分新生代，老生代，而是在Java堆中任何区域都可以进行垃圾回收

  - 面向局部收集

    - 整体来看是“标记-整理”算法
    - 两个Region之间来看，是“标记-复制”算法

  - 基于Region的内存布局形式：

    - 把连续Java堆划分成多个<u>大小相等</u>的独立区域 Region
      - Region 是单次垃圾回收的最小单位
      - `-XX：G1HeapRegionSize`。设置Region大小，取值范围为1MB～32MB，且应为2的N次幂。
    - 每个Region都可以根据需要，扮演
      - Eden：扮演新生代
      - Survior：扮演新生代
      - 老年代
    - Humongous区域：存储大对象
      - 大对象：内存占用<u>超过 1 Region 容量一半</u>的对象
      - 超级大对象：内存占用超过 1 Region 容量的对象。存放进N个连续的Humongous区域。

  - 维护垃圾回收优先级列表

    - 每次根据用户设定的收集停顿时间

      `-XX：MaxGCPauseMillis`：默认值200ms

    - 收集价值收益最大的Region

- 步骤

  - **初始标记**：标记GC Roots能直接关联的对象，并修改TAMS指针的值

  - **并发标记**：对堆中对象进行可达性分析，递归扫描堆里对象图，找到要回收的对象

  - **最终标记**：处理并发阶段结束后遗留的SATB记录

  - **筛选回收**：负责更新Region的统计数据，对各个Region的回 收价值和成本进行<u>排序</u>，根据用户所期望的停顿时间来制定回收计

    划，可以自由选择任意多个Region 构成回收集，然后把决<u>定回收的那一部分Region的存活对象复制到空的Region中</u>，再清理掉

    整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

![image-20220210151308029](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202101513263.png)

- 缺点：
  - 卡表实现复杂：每个Region都有一个卡表，因此G1的记忆集的内存占用大
  - G1对写屏障的复杂操作要比CMS消耗更多的运算资源。
    - CMS的写屏障实现是直接的同步操作
    - G1是实现类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到<u>队列</u>里，然后再异步处理



> - 如何解决跨Region引用对象问题？
>   - 使用记忆集避免全堆作为GC Roots扫描
>   - 每个Region都维护自己的**记忆集**
>     - 记忆集是哈希表，Key是别的Region起始位置，Value是一个集合，存储卡表索引号
>     - 记忆集记录别的Region指向自己的指针
>     - 标记这些指针分别在哪些卡页的范围
> - 如何保证垃圾收集线程和用户工作线程互不干扰？
>   - 用户线程改变对象引用关系时，不能打破原本的对象图结构
>     - 原始快照算法 SATB 
>   - 垃圾回收时，用户有新对象创建
>     - 两个TAMS指针，把Region中一部分空间用于并发回收过程中的新对象分配，新对象地址必须在这两个指针上
>     - 如果垃圾回收速度赶不上分配速度，会导致Full GC而冻结用户线程
> - 如何建立可靠的停顿预测模型？（如何满足用户设定的收集停顿时间期望值）
>   - 衰减均值





#### 3.5 低延迟垃圾收集器

> 衡量垃圾收集器的三项指标：内存占用、吞吐量和延迟
>
> 随着硬件的升级，吞吐量不断提高，但是延迟也不断升高。所以解决延迟问题变得非常重要。

3.5.1 Shenandoah收集器

3.5.2 ZGC收集器

