# JVM

## 自动内存管理

### 1 概述

### 2 内存区域

#### 2.1 运行时内存区域

![image-20220125101616135](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202201251016250.png)



![image-20200708094507624](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203122152417.png)



##### 2.1.1 栈、堆、方法区的交互关系

1. Person类 的.class 信息存放在方法区 (运行时常量池)中
2. person变量 存放在 Java虚拟机栈的局部变量表中
3. person对象 存放在 Java 堆中

4. 在 person 对象中，**有个指针指向方法区中的 person 类型数据**，表明这个 person 对象是用方法区中的 Person 类型 new 出来的

![image-20200708094747667](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203122156599.png)



##### 2.1.2 程序计数器

- 线程**私有**：每个线程拥有独立的程序计数器，且互不影响。

- 当前线程所执行的字节码的行号指示器。

- 字节码解释器工作时，就是通过改变**程序计数器**来选取下一条要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等等）。

  

##### 2.1.3 Java虚拟机栈

- 线程**私有**
- 描述Java方法（字节码）内存模型
  - Java方法执行时，Java虚拟机创建 **stack frame**（存储局部变量表、操作数栈、动态连接、方法出口等信息）
  - 方法执行过是 stack frame 在虚拟机栈中入栈和出栈的过程

- 两个异常：
  - StackOverFlow：线程请求的栈深度超过了虚拟机栈所允许的深度
  - OutOfMemoryError：如果虚拟机栈容量可以动态扩展，栈扩展时无法申请到更多的内存。



##### 2.1.4 本地方法栈

- 和虚拟机栈类似，只是是为的是本地（native）方法服务的。



##### 2.1.5 堆

- 线程**共享**
- 虚拟机启动时创建，存放对象实例
- 线程有私有的缓冲区来提高获取对象实例的效率
- 堆是由GC管理的内存区域



##### 2.1.6 方法区

- 线程**共享**
- 逻辑区域
- 存储被虚拟机加载的**类型信息（Class）**、**常量**、**静态变量**、即时编译器编译后的代码缓存等数据。



方法区：

1）Class

2）运行时常量池：字面量和符号引用



#### 2.2 对象（普通Java对象）

##### 2.2.1 (⭐)对象的创建

![image-20220205143228626](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051432679.png)

1. 确定类加载：在常量池中定位符号引用，然后定位到类，检查该类有没有被加载、解析和初始化过

2. 在Java堆中划分内存，

   - **指针碰撞：**如果Java堆中内存是绝对规整的，

     - 所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，
     - 分配内存就仅仅是把<u>那个指针向空闲空间方向挪动一段与对象大小相等的距离</u>。	

   - **空闲列表：**如果Java堆中的内存不是规整的

     - 虚拟机就必须维护一个列表，记录上哪些内存块是可用的，
     - 在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

     

     对象创建是个很频繁的活动，因此需要解决分配空间时的线程安全问题：

     1）**CAS+失败重试**：CAS是乐观锁的实现方式。<u>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性</u>

     > 乐观锁和悲观锁是两种思想，为了解决并发场景下数据竞争的问题
     >
     > - 乐观锁：不会上锁。因为认为别人不会同时修改操作，执行更新操作的时候，判断下此期间是否有人修改操作，如果有，则放弃更新。
     >
     >   乐观锁实现方式：
     >
     >   - **CAS**：Compare and Swap：如果内存空间 valueOffset 等于预期的值A，则将该位置值更新成值B，否则不进行操作。
     >
     >     CAS是CPU支持的原子操作。在硬件层面保证原子性。
     >
     >     > CAS的缺点：
     >     >
     >     > ABA问题
     >     >
     >     > 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：
     >     >
     >     > (1)线程1读取内存中数据为A；
     >     >
     >     > (2)线程2将该数据修改为B；
     >     >
     >     > (3)线程2将该数据修改为A；
     >     >
     >     > (4)线程1对数据进行CAS操作
     >     >
     >     > 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。
     >     >
     >     > 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
     >     >
     >     > 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。
     >
     >   - **版本号机制**：数据增加版本号字段，数据每更新一次，版本号加一
     >
     > - 悲观锁：上锁，需要额外的资源。线程在对数据进行操作时，会添加排他锁，要是其他线程想要操作该数据，则会被堵塞。

     2）**本地线程分配缓冲（TLAB）：**哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完

     了，分配新的缓存区时才需要同步锁定。

3. 初始化零值：
   - 将分配到的内存空间（但不包括对象头）都初始化为零值。
   - 如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。
   - 这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

4. 设置对象头。

   - 对象属于哪个类

   - 怎么找到类的元数据信息

     > 元数据：Data that describes other data，包括类、字段、方法定义和其他信息

   - 对象哈希码（延后到真正调用Object::hashCode()方法时才计算）

   - 对象的GC分代年龄

5. 执行 `<init>` 方法。
   - 构造函数，对象初始化



##### 2.2.2 对象布局

1. 对象头 Header，包括两类信息

   - 存储对象自身的运行时数据
     - 哈希码
     - GC分代年龄
     - 锁状态标志
     - 线程持有的锁
     - 偏向线程ID
     - 偏向时间戳
   - 类型指针：即对象指向它的类型元数据的指针。
     - Java虚拟机通过这个指针来确定该对象是哪个类的实例
     - 但是查找对象的元数据信息并不一定要经过对象本身
     - 如果对象是数组，则还保存了数组的长度信息

2. 实例数据 Instance Data

   - 对象在代码里面所定义的各种类型的字段内容

   - HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，

     OOPs）

3. 对齐填充 padding

   - HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是<u>8字节的整数倍</u>
   - 对象头已经是8字节的整数倍
   - 通过 padding 来使对象的内存大小为8字节的整数倍



##### 2.2.3 对象访问

Java程序通过**Java栈**上reference数据来操作**堆**上的具体<u>对象实例</u>。

有两种方式：

- 方式一：句柄访问

  - reference数据存储句柄
  - 好处：对象移动时（如被回收），只需改变实例数据的指针，reference本身不用动

  ![image-20220205144044306](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051440383.png)

- 方式二：直接指针访问

  - reference 存储
  - 好处：访问速度快

  ![image-20220205145323781](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051453861.png)









### 3 垃圾收集器与内存分配策略

#### 3.1 对象存活判定算法

##### 3.1.1 引用计数算法

对象中添加引用计数器，当有一个地方引用该对象时，计数器+1；引用失效时，计数器-1。

该方法有问题，比如：

```
ReferenceCountingGC objA = new ReferenceCountingGC();
ReferenceCountingGC objB = new ReferenceCountingGC();
objA.instance = objB; // objA引用计数器+1
objB.instance = objA; // objB引用计数器+1

objA = null;
objB = null;
// 假设在这行发生GC，objA和objB是否能被回收？
System.gc(); //不能，objA和objB引用计数器不为0，但实际上这两个对象已死
```

Java并没有使用这个方法。



##### 3.1.2 可达性分析算法

> “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference  Chain）。如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

![image-20220205151101315](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202051511378.png)



- 可固定作为GC Roots的对象：

  - **虚拟机栈中引用的对象**。

    如：各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

  - **方法区中静态属性引用的对象**。如引用类型静态变量。

  - **方法区中常量属性引用的对象**。如String常量池中的引用。

  - **本地方法栈中 Native 方法引用的对象**

  - **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象

    比如NullPointExcepiton、OutOfMemoryError等，还有系统类加载器

  - **所有被同步锁持有的对象**

  - **反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等**。

  - **其他对象“临时性”地加入**。

    譬如分代收集和局部回收（Partial GC），



##### 3.1.3 引用

强度：强引用 > 软引用 >弱引用 > 虚引用 

- 强引用：引用赋值。对象强引用关系存在时，GC永远不会回收该对象。

  ```
  Object obj = new Object(); //强引用
  ```

  

- 软引用：可以用，但不必要。

  ​				内存溢出异常前，先对这些对象进行第二次回收，如果内存仍不足，则抛出内存溢出异常。

- 弱引用：不必要的内存。弱引用的对象只存活到下一次GC工作前。下一次GC回收对象时，会回收掉弱引用的对象。

- 虚引用：虚引用对对象生存时间不构成任何影响，也不能通过虚引用取得对象实例，只是为了GC回收该对象时，获得一次系统通知。

  

##### 3.1.4 对象生存和死亡

对象至少经过两次标记后，才会被宣告死亡。

- <u>第一次标记</u>：通过 reference chain 不可达的对象
- 筛选对象是否有必要执行 finalize() 方法。
  - 没有必要
    - 虚拟机已经调用过该对象的finalize()方法
    - 或 该对象没有覆盖 finalize() 方法
- 有必要执行 finalize() 方法
  - 对象放入F-Queue队列中
  - 虚拟机创建一条低优先级的 Finalizer 线程去执行队列中对象的finalize()方法
    - Finalizer 线程只调用 finalize() 方法，但不保证会等待它运行结束。

- 如果对象调用 finalize() 方法后拯救了自己（重新和reference chain上的对象关联），那么就逃脱一死。
- <u>第二次标记</u>：对象调用 finalize() 方法后不能拯救自己，就被二次标记。

> 任何一个对象的finalize()方法都只会被系统自动调用一次





##### 3.1.5 回收方法区

- 回收废弃常量
  - 没有任何对象引用常量池中的某个常量，该常量就可以被清理。
- **允许**回收不再使用的类型（类）
  - 该类的实例都被回收
  - 该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。





#### 3.2 垃圾收集算法

> 分代收集理论
>
> - 弱分代假说：大多数对象都是朝生夕灭的
> - 强分代假说：熬过多次垃圾收集的对象，更加难以被消灭
> - 跨代引用假说：存在相互引用的两个对象，应该同时生存或者同时死亡
>
> 所以，Java堆中应该划分出多个区域，至少有个“新生代”区域集中朝生夕灭的对象，一个"老年代"区域放入难以回收的对象。
>
> 在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。
>
> 新生代上有个数据结构 “记忆集”，标识出老年代上存在跨代引用（老年代引用新生代对象）关系的对象。

- 整个Java堆 Full GC
  - 新生代 Minor GC
  - 老生代 Major GC



##### 3.2.1 标记-清除算法

1. 先标记出要回收的对象
2. 标记完清除对象。

- 缺点：
  - 效率低
  - 空间碎片化



##### 3.2.2 标记-复制算法

1. 内存中额外留下一片区域
2. 每当对象清除完，把剩下的对象复制到保留区域中。

![image-20220207145233806](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202071452936.png)

- 优点：
  - 空间连续
- 缺点：
  - 内存空间浪费
  - 存活对象多的时候，复制开销大



##### 3.2.3 标记-整理算法

标记后，并不直接清除对象，而是把存活对象移动到内存空间的一端，然后清除掉存活对象边界以外的对象。

- 缺点：
  - 移动对象复杂





#### 3.3 （先跳过，后面看）HotSpot 算法细节实现

3.3.1 根节点枚举

3.3.2 安全点

3.3.3 安全区域



##### 3.3.4 记忆集与卡表

1. 记忆集：一种抽象数据结构
   - 记录 非收集区域 指向 收集区域 的<u>指针集合</u>
2. 卡表 Card Table ：一种记忆集的具体实现
   - HotSpot用字节数组来实现，每个元素标识内存区域中一块特定大小的内存块——卡页
     - 卡页内存在跨代指针，则脏了，标识为1
     - 否则，标识为0



##### 3.3.5 写屏障

写屏障技术<u>维护卡表</u>

- 写前屏障：引用类型字段赋值前进行操作
- 写后屏障：引用类型字段赋值后进行操作

> 伪共享问题：
>
> ​	现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。

![image-20220210160656851](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202101606022.png)

- 如何避免伪共享问题？
  - 先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏



##### 3.3.6 并发的可达性分析

三色标记 (Tri-color Marking)

- 白色：对象未被垃圾收集器访问过
  - 可达性分析开始时，所有对象都是白色的
  - 可达性分析结束时，白色的对象即为不可达对象
- 黑色：<u>对象</u>及<u>对象所有的引用</u>已经被访问过。
- 灰色：对象已经被访问过，但至少有一个引用还没被扫描。



用户线程和垃圾回收器在并发期间两种情况

- 用户线程改变了引用，使原本要回收的垃圾错误标记成存活 —> 产生浮动垃圾，可以接受
- 用户线程改变了引用，使原本存活的垃圾错误改成消亡 —> 不可接受

对象消失的两个条件：

1. 赋值器插入一条或多条从黑色对象到白色对象的引用
   - 黑色对象已经是该对象和所有引用都访问过的对象了，所以新添加的引用不会被访问，于是产生了对象消失的问题。
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

解决办法：

- 增量更新：黑色对象新添引用到白色对象时，记录下新插入的引用记录，并发扫描结束后，从记录处以黑色对象为根，重新扫描一次。
- 原始快照：灰色对象要删除指向白色对象的引用关系时，将删除的引用记录下来，并发扫描结束后，将记录过的引用关系中灰色关系为根，重新扫描一次。



#### 3.4 经典垃圾收集器

![image-20220208145642953](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081456037.png)



- 并行 Parallel: 同一时间有多条垃圾收集器线程在工作，且默认用户工作线程是停止的
- 并发 Concurrent：垃圾收集器和用户线程都在运行。但是垃圾收集器占用了部分系统资源，因此应用程序的吞吐量受到影响。



- 吞吐量 = 运行用户代码时间 / （ 运行用户代码时间 + 运行垃圾收集时间）



##### 3.4.1 新生代收集器

1. ==**Serial**==

![image-20220208150630614](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081506677.png)

- 特点：
  - 新生代
  - 单线程
    - 使用一条收集线程去回收对象
    - 垃圾收集时，会暂停其他的工作线程
- 优点：
  - 简单高效
  - 额外内存消耗最小

- 缺点：
  - 会停掉用户正常的工作线程



2. ==**ParNew**==

 ![image-20220208150735709](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202081507777.png)

Serial 收集器多线程并行版本



3. ##### ==Parallel Scavenge==

- 特点：

  - 新生代收集器
  - 基于标记-复制
  - 尽可能地控制吞吐量
    - 吞吐量 = 运行用户代码时间 / （ 运行用户代码时间 + 运行垃圾收集时间）
  - 两个参数
    - -XX： **MaxGCPauseMillis** 最大垃圾停顿时间。牺牲吞吐量和新生代内存大小实现的
    - -XX：**GCTimeRatio** 直接设置吞吐量大小。

  - -XX：UseAdaptiveSivePolicy 自适应调节吞吐量



##### 3.4.2 老年代收集器

1. ==**Serial Old**==

- 特点：

  - 标记-整理

  ![image-20220209193150187](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202091931282.png)



2. ==**Parallel Old**==

![image-20220209195527667](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202091957314.png)

- 特点：
  - 支持多线程并发
  - 标记-整理
  - 可以和 Parallel Scavenge 收集器搭配实现吞吐量优先收集器 



3. ==**CMS收集器**== (Concurrent Mark Sweep)

![image-20220209215127169](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202092151245.png)

- 特点：
  - 以获取<u>最短的回收停顿时间</u>为目标收集器
  - <u>对</u><u>处理器资源敏感</u>（因为是并发操作，并发执行的程序对处理器资源都很敏感）
    - GMS进行垃圾回收时，会占用部分资源，导致用户执行程序变慢，吞吐量降低。
  - 需要<u>预留足够内存空间</u>供用户线程，因此不能等到老年代区满了以后再回收垃圾，而是要在老年代区域中预留内存空间。
    - 如果并发过程中，出现内存不够的情况，就会出现“并发失败”问题
      - 预留方案：冻结用户线程，临时启动Serial Old老年代垃圾回收器。
- 步骤：
  1. **初始标记**：
     - 需要Stop the world （暂停用户线程）
     - 仅仅标记GC Roots能够直接关联的对象
  2. **并发标记**
     - 从GC Roots开始遍历整个对象图
  3. **重新标记**
     - 修正并发标记期间，因为用户线程继续运作而产生变动的对象的标记记录
  4. **并发清除**
     - 清除死亡对象
     - 不移动存活对象

-  缺点：

  - 无法处理“浮动垃圾”

    > 浮动垃圾：
    >
    > 本次垃圾回收中，用户线程在并发执行期间新产生的垃圾，需要等待下次垃圾回收时才能回收。

  - 标记-清除算法，会产生空间碎片。



> 如何保证垃圾收集线程和用户工作线程互不干扰？
>
> - 增量更新算法



##### 3.4.3 G1 

Garbage First

- 特点：

  - Mixed GC模式：
    - 不区分新生代，老生代，而是在Java堆中任何区域都可以进行垃圾回收

  - 面向局部收集

    - 整体来看是“标记-整理”算法
    - 两个Region之间来看，是“标记-复制”算法

  - 基于Region的内存布局形式：

    - 把连续Java堆划分成多个<u>大小相等</u>的独立区域 Region
      - Region 是单次垃圾回收的最小单位
      - `-XX：G1HeapRegionSize`。设置Region大小，取值范围为1MB～32MB，且应为2的N次幂。
    - 每个Region都可以根据需要，扮演
      - Eden：扮演新生代
      - Survior：扮演新生代
      - 老年代
    - Humongous区域：存储大对象
      - 大对象：内存占用<u>超过 1 Region 容量一半</u>的对象
      - 超级大对象：内存占用超过 1 Region 容量的对象。存放进N个连续的Humongous区域。

  - 维护垃圾回收优先级列表

    - 每次根据用户设定的收集停顿时间

      `-XX：MaxGCPauseMillis`：默认值200ms

    - 收集价值收益最大的Region

- 步骤

  - **初始标记**：标记GC Roots能直接关联的对象，并修改TAMS指针的值

  - **并发标记**：对堆中对象进行可达性分析，递归扫描堆里对象图，找到要回收的对象

  - **最终标记**：处理并发阶段结束后遗留的SATB记录

  - **筛选回收**：负责更新Region的统计数据，对各个Region的回 收价值和成本进行<u>排序</u>，根据用户所期望的停顿时间来制定回收计

    划，可以自由选择任意多个Region 构成回收集，然后把决<u>定回收的那一部分Region的存活对象复制到空的Region中</u>，再清理掉

    整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

![image-20220210151308029](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202101513263.png)

- 缺点：
  - 卡表实现复杂：每个Region都有一个卡表，因此G1的记忆集的内存占用大
  - G1对写屏障的复杂操作要比CMS消耗更多的运算资源。
    - CMS的写屏障实现是直接的同步操作
    - G1是实现类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到<u>队列</u>里，然后再异步处理



> - 如何解决跨Region引用对象问题？
>   - 使用记忆集避免全堆作为GC Roots扫描
>   - 每个Region都维护自己的**记忆集**
>     - 记忆集是哈希表，Key是别的Region起始位置，Value是一个集合，存储卡表索引号
>     - 记忆集记录别的Region指向自己的指针
>     - 标记这些指针分别在哪些卡页的范围
> - 如何保证垃圾收集线程和用户工作线程互不干扰？
>   - 用户线程改变对象引用关系时，不能打破原本的对象图结构
>     - 原始快照算法 SATB 
>   - 垃圾回收时，用户有新对象创建
>     - 两个TAMS指针，把Region中一部分空间用于并发回收过程中的新对象分配，新对象地址必须在这两个指针上
>     - 如果垃圾回收速度赶不上分配速度，会导致Full GC而冻结用户线程
> - 如何建立可靠的停顿预测模型？（如何满足用户设定的收集停顿时间期望值）
>   - 衰减均值





#### 3.5 低延迟垃圾收集器

> 衡量垃圾收集器的三项指标：内存占用、吞吐量和延迟
>
> 随着硬件的升级，吞吐量不断提高，但是延迟也不断升高。所以解决延迟问题变得非常重要。

3.5.1 Shenandoah收集器

3.5.2 ZGC收集器





## 虚拟机执行子系统

### 4 类文件结构

#### 4.1 Class类文件结构

##### 4.1.1 魔数和版本号

1. 魔数：头4个字节，0xCAFEBABE 

   ​			用来确定是不是class文件

2. 版本号：

   - 5和6是次版本号
   - 7和8是主版本号



##### 4.1.2 常量池

1. 常量池容量计数值：入口是一项2字节的数据，代表常量池容量计数

   - 计数从1开始
   - 比如：0x0016，十进制是22，则常量池中有21个数，是1~21

2. 字面量

   - 字符串
   - final类型的常量值

3. 符号引用：

   - 导出或开放的Package

   - 类和接口的全限定名

   - 字段的名称和描述符

     > 描述符就是private、public这些

   - 方法的名称和描述符 

   - 方法句柄和方法类型

     > 方法句柄：类似C++函数指针，可以把函数作为参数传入方法。
     >
     > java.lang.invoke包
     >
     > - MethodHandle类
     > - MethodType类

   - 动态调用点和动态常量



##### 4.1.3 访问标志

- 2字节

- 标志类的信息（比如该类是接口还是类，是不是public等等）



##### 4.1.4 类索引、父类索引与接口索引集合

- 类索引 this_class
  - u2类型

- 父类索引 super_class
  - u2类型
  - 除了java.lang.Object，其他类只有一个父类索引
- 接口类型 intefaces：一组u2类型的集合



##### 4.1.5 字符表集合

- 字符表：描述接口或类中声明的**变量**

  ![image-20220225161206498](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202251612645.png)

> - 对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”
> - 用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。



##### 4.1.6 方法表集合

- 访问标志（access_flags）
- 名称索引（name_index）
- 描述符索引（descriptor_index）
- 属性表集合（attributes）

>方法里的代码被存储到方法属性表的code属性里去了



##### 4.1.7 属性表集合

1. **code** 属性

> 对于一个没有参数又没有局部变量的非静态方法，表示局部变量的Locals和表示参数的Args_size仍是1
>
> - 因为在虚拟机调用实例方法时自动传入参数 this

2. **Exceptions** 属性
   - 列举方法 throws 后面的异常
3. **LineNumberTable** 属性
   - 描述源码行号和字节码行号的对应关系

4. **LocalVariableTable** 及 **LocalVariableTypeTable** 属性
   - LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系
   - LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述

5. **SourceFile** 及 **SourceDebugExtension** 属性
   - SourceFile 记录生成这个 Class 文件的<u>源码文件名称</u>
   - SourceDebugExtension 属性用于存储额外的代码调试信息

6. **ConstantValue** 属性
   - ConstantValue会通知虚拟机自动为静态变量赋值
     - 非static的变量是在实例构造器`<init>()`中赋值的
     - static变量则在类构造器`<clinit>()`赋值或者使用ConstantValue

7. **InnerClasses** 属性
   - 记录内部类与宿主类之间

8. **Deprecated** 及 **Synthetic** 属性
   - Deprecate，布尔值。就是`@deprecated`标记的字段或者方法。
   - Synthetic，布尔值。表示该字段或者方法不是源码的，而是编译器自动生成的

9. **StackMapTable** 属性
   - 字节码验证器。在编译阶段将一系列的验证类型（Verification Type）直接记录在Class文件之中

10. **Signature** 属性
    - 用于反射获取泛型类型。

11. **BootstrapMethods **属性
    - 保存invokedynamic指令引用的引导方法限定符

12. **MethodParameters** 属性
    - 记录方法的各个形参名称和信息

13. **模块化相关**属性
    - Module属性：除了表示该模块的名称、版本、标志信息以外，还存储了这个模块requires、exports、opens、uses和provides定义的全部内容
    - ModulePackages属性：用于描述该模块中所有的包，不论是不是被export或者open的。
    - ModuleMainClass属性：确定该模块的主类（Main Class）

14. **运行时注解相关**属性
    - 存储源码中注解信息



#### 4.2 字节码指令



#### 4.3 公有设计，私有实现



### 5 类加载机制

类加载机制：Java虚拟机把描述类的数据从编译好的Class文件里加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类的过程。

#### 5.1 类加载时机

##### 5.1.1 类的生命周期

![image-20220226133318320](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202261333431.png)

1. 加载
2. 连接
   - 验证
   - 准备
   - 解析
3. 初始化
4. 使用
5. 卸载

顺序确定的：加载—>验证—>准备—>初始化—>卸载

类加载过程：加载—>连接（验证—>准备—>解析）—>初始化



- 主动引用：**初始化**的<u>六</u>种情况（**<u>有且只有六种</u>**）：

  - 遇到new、getstatic、putstatic、invokestatic四条字节码指令时
    - **new对象**
    - **读取和设置static字段**
    - **调用static方法**
  - **反射**：使用java.lang.reflect对类进行反射调用时
  - **子类—>父类**：初始化类时，类的父类还没初始化
    - 注意：子接口初始化时，并不需要父接口进行初始化。
  - **主类**：虚拟机启动时，要先初始化主类 (包含`main()`方法的类)
  - **方法句柄**：当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
  - **定义了default方法的接口**：接口含有default修饰的方法时，如果实现类发生了初始化，那该接口必须在其前先初始化

- 被动引用：除了主动引用的六种情况，其他引用类型不会触发类的初始化。

  - 示例一：

  ```java
  public class ClassInitTest {
      public static void main(String[] args) {
          System.out.println(SubClass.value);
      }
  }
  
  class SuperClass {
      static {
          System.out.println("superclass");
      }
  
      public static int value = 123;
  }
  
  class SubClass extends SuperClass {
      static {
          System.out.println("subclass");
      }
  }
  ```

  执行结果：

  ![image-20220226140248616](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202261402657.png)

  分析：

  > static修饰的代码块：随着类的加载而执行，且执行一次。
  >
  > 非static的代码块：随着对象的创建而执行。

  对于static的字段，只有直接定义了该字段的类会被初始化。而子类引用父类的static字段，只会引发父类初始化，而不会引发子类初始化。
  

  - 示例二：

    ```java
    package org.fenixsoft.classloading;
    /**
    * 被动使用类字段演示二：
    * 通过数组定义来引用类，不会触发此类的初始化
    **/
    public class NotInitialization {
    	public static void main(String[] args) {
    		SuperClass[] sca = new SuperClass[10];
    	}
    }
    ```

  - 示例三：

    ```java
    package org.fenixsoft.classloading;
    /**
    * 被动使用类字段演示三：
    * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
    **/
    public class ConstClass {
    	static {
    		System.out.println("ConstClass init!");
    	}
    	public static final String HELLOWORLD = "hello world"; // final定义的常量
    }
    /**
    * 非主动使用类字段演示
    **/
    public class NotInitialization {
    	public static void main(String[] args) {
    		System.out.println(ConstClass.HELLOWORLD);
    	}
    }
    ```

    

​		

#### 5.2 类加载过程

加载—>连接（验证—>准备—>解析）—>初始化

##### 5.2.1 加载

1. 通过类的全限定名称来获得定义此类二进制的字节流

2. 将字节流定义的静态存储结构转化为方法区的运行时数据结构

   > ##### 2.1.5 方法区
   >
   > - 逻辑上的区域
   > - 线程**共享**
   > - 存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

3. 内存中创建一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口



##### 5.2.2 验证

连接阶段第一步，用于确保Class文件中的字节流信息符合Java虚拟机的规范

1. 文件格式验证
   - 魔数
   - 版本
   - 常量池常量
   - 指向常量的索引
   - 编码规范
   - 文件是否完整或被附加其他信息

2. 元数据验证

   - 类
   - 字段
   - 方法定义

3. 字节码验证（最复杂）：用于确定程序语义是否合法、符合逻辑

   > 停机问题：
   >
   > 程序无法判断程序会在有限时间内完成，还是会死循环

4. 符号引用验证：该验证发生在解析阶段，用于校验虚拟机将符号引用转化为直接引用时，是否存在问题。



##### 5.2.3 准备

正式为类中static变量分配内存到方法区（一个逻辑区域）和**<u>设置初始值</u>**（通常为0值）

```java
/*
* 初始值为0
*/
public static int value = 123;
```



```java
/*
* 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置将value赋值为123
*/
public static final int value = 123;
```



##### 5.2.4 解析

将java中符号引用替换成直接引用

- 符号引用：
  - 用一组符号来描述所引用的目标。引用的目标不一定是已经加载到虚拟机里的东西。
- 直接引用：
  - 直接指向目标的指针、相对偏移量或者直接定位到目标的句柄。
  - 直接引用跟虚拟机实现的内存布局相关。
  - 直接引用的目标必须已经加载在虚拟机内存里了。



1. 类和接口的解析
2. 字段解析
3. 方法解析
4. 接口方法解析



##### 5.2.5 初始化

初始化阶段是执行类构造器`<clinit>()`的阶段。

1. **类初始化：**

   - `<clinit>()` 就是给**类的变量赋值**和**执行static{}语句块**时创建和调用的方法。

   > 注意：
   >
   > - 类在准备阶段已经给类设置了初始值，所以初始化阶段是给类的变量进行赋值。
   >
   > - `<clinit>()`和`<init>()`的区别：
   >
   >   - 作用不同
   >
   >     - `<clinit>()`是类在初始化的时候，jvm调用的方法
   >     - `<init>()`是new实例时，类constructor执行的方法。
   >
   >   - 子类父类
   >
   >     - `<clinit>()`不需要显式调用父类的构造器；父类的`<clinit>()`一定在子类执行的时候，已经执行完了。
   >
   >       所以父类的static{}会比子类先执行。
   >
   >     - `<init>()` 要先执行父类的`<init>()`，再执行子类的`<init>()`



2. **接口初始化：**
   - `<clinit>()`  是**接口变量赋值**时，调用的方法时创建和调用的方法。
   - 执行接口`<clinit>()`  方法，不需要父接口的`<clinit>()` 方法先执行。
   - 实现类`<clinit>()` 方法执行时，不需要接口的`<clinit>()`方法先执行。



3. **多线程下的类初始化：**
   - 多个线程同时去初始化一个类时，只会有一个线程执行这个类的`<clinit>()` 方法，其他线程会被阻塞等待。
   - 同一个类加载器中，**<u>一个类只会被初始化一次</u>**，所以当执行`<clinit>()` 方法的线程完成以后，其他线程被唤醒后并不会再进入`<clinit>()` 方法。



#### 5.3 类加载器

##### 5.3.1 概述

类加载器：用于实现类的加载，即“通过一个类的全限定名来获取描述该类的二进制字节流”。

- 比较两个类知否相等，**必须是来自同一个类加载器**。
  - 包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果



##### 5.3.2 双亲委派模型

自JDK 1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。

- 三层类加载器：
  1. **启动类加载器**（Bootstrap Class Loader）
     - 由C++实现
     - 加载 <JAVA_HOME>\lib 目标下，或被 -Xbootclasspath 参数所指定的路径中存放的类，且能被JVM识别的类加载到JVM内存中。
     - 启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。
  2. **拓展类加载器**（Extension Class Loader）
     - 由Java实现
     - 加载 <JAVA_HOME>\lib\ext 目标中，或者被java.ext.dirs系统变量所指定的路径中所有的类库
     - 开发者可以直接在程序中使用扩展类加载器来加载Class文件
  3. **应用程序类加载器**（Application Class Loader）
     - ClassLoader类中的`getSystemClassLoader()`方法的返回值，所以有些场合也称“系统类加载器”。
     - 它负责加载用户类路径（ClassPath）上所有的类库。
     - 开发者同样可以直接在代码中使用这个类加载器。

![image-20220228061748811](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202202280617935.png)

- 双亲委派模型

  - 除了顶层的启动类加载器，其他加载器都必须有父类加载器

  - 父子关系不是继承实现的，而是**<u>组合</u>**实现的。

  - 工作流程：

    1. 一个类加载器收到类加载请求，先将请求委派给父类加载器去完成。
    2. 每一层类加载器都是如此。
    3. 当父加载器无法处理请求的时候，子加载器才会尝试去完成。

  - 好处：

    - 使得Java中的类，通过双亲委派模型，而获得了带有优先级的层级关系。

      比如 java.lang.Object 类，存放在rt.jar 中，则必然是由启动类加载器去完成。因此，**Object类在程序的各种类加载器环境中都能够保证是一个类**。

    - 能够保证Java程序的稳定运行。



##### 5.3.3 破坏双亲委派模型



#### 5.4 Java模块化系统







## 虚拟机执行子系统

### 6 虚拟机字节码执行引擎

java代码通过javac编译成字节码(.class)，再由jvm解释编译成机器码（也叫本地代码）

#### 6.1 运行时栈帧结构

- java以**方法**为最基本执行单元

- 栈帧是虚拟机栈的元素，存储了

  - 方法的局部变量表
  - 操作数栈
  - 动态连接
  - 方法返回地址

  ![在这里插入图片描述](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203010924779.png)

>  当前栈帧和当前方法：
>
> - 当前栈帧：线程中只有栈顶的栈帧是运行着的，栈顶栈帧就叫当前栈帧。
> - 当前方法：当前栈帧所关联的方法叫当前方法。



##### 6.1.1 局部变量表

- 局部变量表的容量由class字节码中，方法的code属性的max_locals确定
- 变量槽：局部变量表容量的最小单元。《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference **<u>或</u>** returnAddress类型的数据。
- jvm使用**索引定位**的方法来使用局部变量表
  - 32位系统：索引 N 代表第 N 个变量槽
  - 64位系统：索引 N 代表第 N和N+1两个变量槽 
    - 因为对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间

- 当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。

  - 如果执行的是实例方法（没有被static修饰的方法）

    - 那局部变量表中<u>**第0位索引**的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数</u>。
    - 其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽

    > 实例方法：没有static 属性的方法
    >
    > 类方法：static属性的方法

- 局部变量和类变量不同，局部变量不存在赋系统初始值阶段，所以必须要赋值。











## 高效并发

### 7 Java内存模型和线程

#### 7.1 硬件效率与一致性

处理器和内存需要交互。但是I/O速度很慢，所以在处理器和内存之间增加了高速缓存。

![image-20220302215442101](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203022154178.png)

高速缓存会带来新的问题：

- 缓存一致性：共享内存多核系统中，每个处理器有自己的高速缓存，而主内存只有一个，这可能会带来缓存不一致的问题。

> 内存模型：在特定操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。



#### 7.2 Java内存模型

Java内存模型关注的是从内存中取出变量和将变量存储到内存的细节。

##### 7.2.1 主内存和工作内存

![image-20220302215734946](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203022157011.png)

主内存

- 所有变量都存储在主内存中

工作内存

- 每条线程有自己的工作内存
- 工作内存保存了该线程所使用的变量的主内存副本



##### 7.2.2 内存间交互操作

8种**<u>原子</u>**操作：

- 作用于**主内存变量**：
  1. lock：标识为一条**线程独占**的状态
  2. unlock：把lock的变量释放，释放后才能被其他线程锁定。
  3. read：主内存—>工作内存
  4. write：把store操作得到的来自工作内存的变量写入主内存
- 作用于**工作内存变量**：
  5. load：把read操作来自主内存的变量放入工作内存
  6. use：把工作内存中的一个变量传递给执行引擎
  7. assign：把从执行引擎接收的值赋给工作内存中的变量
  8. store：把工作内存中的变量传递给主内存，以便后续的write操作。



load——read

store——write



##### 7.2.3 volatile

jvm提供的最轻量级同步机制

具有两项特性：

1. **可见性**：保证volatile修饰的变量对所有线程具有“可见性”。

   - 普通变量的值在线程中传递时，需要通过主内存才能完成。即，一个线程对普通变量修改值后，需要该线程和主内存进行传递后，其他线程从主内存中读取这个值时，才会看到变量的新值。
   - volatile的变量被一个线程修改值后，所有线程会可以立即得知。因为 ①volatile在改变后，会立即同步到主内存。②volatile变量使用前，会立即从主内存刷新。

   > 注意：
   >
   > - volatile仍然是**<u>线程不安全</u>**的。因为java的运算操作符不是原子操作。比如++操作，在Class文件中由4条字节码指令构成，所以在操作栈顶对变量进行操作时，其他线程可能会改变该变量，这时候工作内存放入主内存的可能就是过期的数据了。
   >
   > - **volatile使用场景**：方法对变量的修改，不依赖方法的原值。比如`setter()`方法
   >
   >   
   >
   > synchronized和final也具有可见性。synchronized会在unlock之前，把变量值同步到主内存

   

2. **禁止指令重排序优化**：

   - 普通变量只会保证方法执行过程中所有依赖赋值结果的地方能获取正确的结果。但是其他操作会因为机器级的指令重排序优化而可能被提前执行。





##### 7.2.4 原子性、可见性、有序性

1. 原子性
   - 几种原子操作：
     - 基本类型（`long`和`double`除外）赋值，例如：`int n = m`；
     - 引用类型赋值，例如：`List<String> list = anotherList`。
2. 可见性
3. 有序性
   - 一个线程内所有操作是有序的。
   - 一个线程观察另一个线程操作是**<u>无序</u>**的：①指令重排序优化；②工作内存和主内存同步延迟



##### 7.2.5 先行发生原则

先行发生原则：A操作先行发生于B操作，就是A操作产生的影响会被B操作观察到。

- **先行发生原则和时间发生先后几乎不存在因果关系。所以不能用时间发生先后来判断线程安全性。**

- 而是要用下面的8个原则来判断：

  1. **程序次序规则**：<u>同一线程</u>内，按照控制流的顺序，书写在前面的操作先行发生于书写在后面的操作。（控制流的顺序≠代码顺序，因为存在循环、分支等结构）

  2. **管程锁定规则**：一个unlock操作先行发生于后面**<u>同一个锁</u>**的lock操作。

  3. **volatile变量规则**：对一个volatile变量的**写**操作先行发生于后面对这个变量的读操作。

  4. **线程启动规则**：Thread对象的`start()`方法先行发生于此对象的每一个动作。

  5. **线程终止规则**：线程中所有操作都先行发生于线程的终止操作。

  6. **线程中断规则**：线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生。

  7. **对象终结规则**：一个对象的初始化完成先行发生于它的`finalize()`方法的开始。

     > finalize()方法：当对象变成(GC Roots)不可达时,GC会判断该对象是否覆盖了finalize方法,若未覆盖,则直接将其回收。否则,若对象未执行过finalize方法,将其放入F-Queue队列,由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后,GC会再次判断该对象是否可达,若不可达,则进行回收,否则,对象“复活。

  8. **传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C。



#### 7.3 线程

进程是资源分配的最基本单位，线程是调度的最基本单位。

线程的实现有三种方式：

1. 内核线程实现（1:1实现）

   KLT：内核线程

   LWP：轻量级线程

   ![image-20220303173426811](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203031734899.png)

   

2. 用户线程实现（1:N实现）

   UT：用户线程

   ![image-20220303173515685](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203031735774.png)

   

3. 混合级线程实现——用户线程加轻量级混合实现（N:M实现）

   ![](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203031735332.png)



#### 7.4  Java和线程

Java线程主流为：1：1模型，线程的调度交给操作系统去处理

Java线程分为：

- 守护线程
  - 守护线程适用于服务其他线程的。如垃圾回收线程。
  - JVM退出时，守护线程会立即停止。即 “The Java Virtual Machine exits when the only threads running are all daemon threads”。
  - 当还有非守护线程还在运行时，JVM就不会停止。
- 用户线程



##### 7.4.1 Java线程调度

- 线程调度2种方式：
  1. 协同式调度
     - 线程执行时间由线程控制。
     - 线程自己的工作执行完后，主动通知操作系统切换线程
     - 优点：简单
     - 缺点：程序会堵塞
  2. 抢占式调度
     - 系统分配线程执行时间、
     - java使用抢占式调度

- 虽然java线程调度是操作系统自动完成的，但是可以设置线程优先级。但是线程优先级并不能准确判断哪个线程先执行：
  - 比如Windows的线程优先级会变 (优先级推进器)，且优先级数量比java优先级数量少



##### 7.4.2 状态转换

1. 新建 New
2. 运行 Runnable
3. 无限期等待 Waiting
   - 不会被分配处理器执行时间
   - 需要其他线程显式唤醒
4. 限期等待 Timed Waiting
   - 不会被分配处理器执行时间
   - 一定时间后由系统自动唤醒
5. 阻塞 Blocked
6. 结束 Termnated

![image-20220306100658052](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203061007192.png)



#### 7.5 Java和协程

##### 7.5.1 内核线程的局限

传统web是一个HTTP请求和一个Servlet API线程绑定。

但是现在HTTP请求量很大，需要分布在不同机器上的服务共同完成，每个服务在极短的时间内进行运算。所以线程的频繁调度会增加时间成本，特别是线程调度时间已经接近于计算的时间。

##### 7.5.2 协程

- 轻量

- 当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。
- **协程并没有增加线程数量，只是在线程的基础之上通过<u>分时复用</u>的方式运行多个协程**，





### 8 线程安全和锁优化

#### 8.1 线程安全

> Brian Goetz 给出的线程安全定义：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协同操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。

##### 8.1.1 Java线程安全

- Java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
  1. 不可变
     - 不可变的对象一定是线程安全的。比如把变量设为 final。
  2. 绝对线程安全
     - 完全满足Brian Goetz 给出的线程安全定义。
  3. 相对线程安全
     - 通常意义的线程安全，指对对象的单次操作是线程安全的。
     - 例如：大部分声称线程安全的类都属于这种类型，Vector、HashTable、Collections的 synchronizedCollection()方法包装的集合等都是相对线程安全的。
  4. 线程兼容
     - 对象本身不是线程安全的，但是可以通过<u>调用端</u>正确地使用<u>同步方法</u>来保证对象在并发环境中可以安全的使用。
  5. 线程对立
     - 不管调用端是否采用同步措施，都无法在多线程环境中并发使用代码



##### 8.1.2 线程安全的实现方法

1. ###### 互斥同步/阻塞同步

   - 同步：多个线程访问一个共享数据时，同一时刻只能有一个线程访问该数据。

   - 互斥：实现同步的手段。

   - 互斥同步又称为阻塞同步（Blocking Synchronization），是一种**悲观**的并发策略。

   

   ① **`sychronized`**

   > 互斥实现同步。
   >
   > 在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种**块结构（Block Structured）**的同步语法。synchronized关键字经过**<u>Javac编译</u>**之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令。这两个字节码指令都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果Java源码中的 synchronized 明确指定了对象参数，那就以这个对象的引用作为 reference；如果没有明确指定，那将根据 synchronized 修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的 Class 对象来作为线程要持有的锁。
   >
   > - 普通方法是对象实例 this 
   > - static方法是对应的 Class 对象
   >
   > 根据《Java虚拟机规范》的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit 指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象 锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。

   - 被synchronized 修饰的同步块对同一条线程来说是可重入的。同一线程反复进入同步块也不会出现自己把自己锁死的情况。
   - 被synchronized 修饰的同步块在持有锁的线程执行完毕并释放锁之前，<u>会无条件地阻塞后面其他线程的进入</u>。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。
   - Java线程由操作系统管理，阻塞或唤醒锁需要不断地在用户态和核心态之间切换，十分消耗处理器的时间。

   

   ② **`ReentrantLock`**

   >  java.util.concurrent包中的java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。
   >
   > - 基于 Lock 接口，用户能够以**非块结构（Non-Block Structured）**来实现互斥同步，
   > - 重入锁 `ReentrantLock` 是 Lock 接口最常见的一种实现。
   > - 比 synchronized 新添三个功能：等待可中断、可实现公平锁及锁可以绑定多个条件。

   - 等待可中断：正在等待的线程可以选择放弃等待。
   - 公平锁：多个线程在等待同一个锁时，必须按照申请时间顺序来依次获得这些锁。synchronized是非公平锁，即在锁被释放后，任何等待的线程都有机会获得这把锁。ReentrantLock 默认是非公平锁，但是可以设置成公平锁。不过公平锁会使得 ReentrantLock性能急剧下降。
   - 锁可以绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象。



​		③ synchronized 和 ReentrantLock 的比较

​			1. JDK 5以前，ReentrantLock 性能优势很明显，但JDK 6以后，synchronized 被优化后，synchronized与ReentrantLock的性能基本上能够持平

​			2.·synchronized是在Java语法层面的同步，足够清晰，也足够简单。

​			3.·Lock应该确保在finally块中释放锁，否则一旦受同步保护的代码块中抛出异常，则有可能永远不 会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确 保即使出现异常，锁也能被自动释放。

​			4.Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象 的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体 哪些锁对象是由特定线程锁持有的



2. ###### 非阻塞同步

   - 非阻塞同步是基于冲突检测的**乐观**并发策略。

   - 乐观并发依靠“硬件指令集”
     - 测试并设置 Test-and-set
     - 获取并增加 Fetch-and-Increment
     - 交换 Swap
     - 比较并交换 Compare-and-Swap， CAS
     - 加载链接/条件存储 Load-Linked/Store-Conditional

   - Java使用的是CAS操作

     - 内存位置 V

     - 旧值 

     - 新值 B

     - **CAS**：Compare and Swap：如果内存空间 valueOffset 等于预期的值A，则将该位置值更新成值B，否则不进行操作。

       CAS是CPU支持的原子操作。在硬件层面保证原子性。

       > CAS的缺点：
       >
       > ABA问题
       >
       > 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：
       >
       > (1)线程1读取内存中数据为A；
       >
       > (2)线程2将该数据修改为B；
       >
       > (3)线程2将该数据修改为A；
       >
       > (4)线程1对数据进行CAS操作
       >
       > 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。
       >
       > 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。
       >
       > 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。

   ​	

3. ###### 无同步方案

   - <u>同步与线程安全两者没有必然的联系</u>

   - 有一些代码天生是线程安全的

     - 可重入代码/纯代码（Reentrant Code/Pure Code）：代码可以在执行的任何时刻被中断，然后去执行其他代码

     - 线程本地存储：如果一段代码所需数据和其他代码共享，如果能保证共享数据在同一线程中执行，那就是线程安全的。

       ​						   比如经典的web交互模式：一个请求对应一个线程。

       - 每个Thread对象都保存了一个ThreadLocalMap对象
         - Key是ThreadLocal.threadLocalHashCode
         - Value是本地线程变量
         - 访问入口是ThreadLocal对象

       > 如果一个数据会被多个线程访问，那就声明成 violatile



#### 8.2 锁优化

##### 8.2.1 自旋锁和自适应自旋

1. 自旋锁
   - 自旋锁：如果有一个以上处理器或处理器核心，那可以让晚请求的线程执行一个忙循环（自旋），而不放弃处理器资源。
   - 自旋有次数，如果自旋超过次数仍没有获得锁，那么就会用传统方式挂起线程。
   - 默认关闭，开启：`-XX：+UseSpinning`
   - 自旋次数默认是10次，可以通过 `-XX：PreBlockSpin` 来更改



2. 自适应自旋
   - 自旋的时间不固定，而是由下面的两个情况来决定：
     - 上一个线程在同一个锁上自旋时间
     - 锁拥有者状态



##### 8.2.2 锁消除

> 内存逃逸：
>
> - 方法逃逸
>   - 方法栈帧里的对象被外部方法的引用，导致方法结束后，栈帧里本该被GC回收的对象仍然存活。
> - 线程逃逸
>   - 对象被外部线程访问，导致本该被GC回收的对象仍然存活。

锁消除：虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

- 很多同步操作不是程序员自己加的

  比如：

  ```java
  public String concatString(String s1, String s2, String s3) {
  	return s1 + s2 + s3;
  }
  ```

  在JDK5之前（JDK5以后用StringBuilder），会被优化成StringBuffer进行连续 `append()` 操作

  ```java
  public String concatString(String s1, String s2, String s3) {
      StringBuffer sb = new StringBuffer();
      sb.append(s1);
      sb.append(s2);
      sb.append(s3);
      return sb.toString();
  }
  ```

  StringBuffer是线程安全的，每个 `append()` 都会进行同步操作，同步锁是对象sb。但是经过逃逸分析，对象sb不会逃逸出该方法，也没有其他线程使用这个对象，因此，在服务器即时编译阶段，会把这个锁给消除掉。



##### 8.2.3 锁粗化

一般来说，同步块的作用范围尽可能小一些 ——> 只在共享数据的实际作用域中才进行同步，这是为了尽可能地减少同步操作，并且即使发生同步，其他线程也能尽快拿到锁。

但是，有些情况上面的原则就不适合，比如 **8.2.2 锁消除** 中的例子，这时候同步块作用于每个 append() 只会造成性能上的浪费，所以，虚拟机会把同步块粗化到第一个append上面和最后一个append下面。



##### 8.2.4 轻量级锁

> HotSpot虚拟机对象头分成两个部分：
>
> - 一部分存储对象自身运行时数据，如哈希值，GC分代年龄等。
> - 一部分存储指向方法区对象类型数据的指针。对象类型数据即<u>对象所属类的信息</u>

![image-20200708094747667](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203122157648.png)



轻量级锁：





##### 8.2.5 偏向锁

