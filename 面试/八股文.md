# 面试题

2、Java集合框架了解哪些？总体架构？常用的一些类的特性说一说 

  

  10、分段锁是用的什么锁？ 

  11、Java中的锁你了解多少？ 

4，mysql索引
5，redis的持久化，aof和rdb
6，aof重写



## Java篇

### 1. ArrayList和LinkedList 的区别？

1. 底层实现不同：他们的底层实现不一样。ArrayList 底层实现是数组，而 LinkedList 底层是双向循环链表。
2. 适用场景不同：
   - ArrayList适合快速读取元素的场景。然而对于元素的插入和删除，需要大量的移动其他的元素。
   - 而LinkedList适合插入和删除频繁的场景。但是对于指定位置元素的查询，需要对链表进行遍历。
     - LRU的实现。
3. 空间占用不同：
   - ArrayList底层是数组，而LinkedList除了要保存节点元素外，还要保存pre和next指针，因此更占空间。



#### ArrayList和LinkedList插入元素时，谁的效率高？

添加元素相关的操作时不说场景的情况下，说不定谁的效率高。

#### ArrayList和LinkedList是否线程安全？有哪些安全的？

不是线程安全的。

- **ArrayList**：比如现在有线程A和线程B同时想要在0的位置add元素，此时ArrayList的size为0。
  - A线程在0位置添加元素后，在size++之前，因为一些原因被阻塞。
  - B线程读取到size仍为0，则在0位置添加元素后，size++。
  - A线程再让size++。
  - 最终，ArrayList里只有1一个元素，size却为2。

- **LinkedList**：比如现在有线程A和线程B同时想要在链表末尾add元素。
  - 线程A获取到链表的last节点，并且指定l=last，此时，A因为一些原因被堵塞。
  - 线程B正常地在链表末尾添加新的节点。
  - 线程A恢复运行，在l后面添加新元素。
  - 这时候，线程B添加的新节点实际上已经访问不到了。

**有哪些线程安全的**：

- 方法**Collections.synchronizedList(List list)**;
  - 当传入的 list 是 ArrayList 时，返回 SynchronizedRandomAccessList 对象；传入 LinkedList 时，返回 SynchronizedList 对象
  - get, set, add 等操作都加了 `sychronized(mutex)` 对象锁，再将操作委托给最初传入的 list。

- **ConcurrentLinkedQueue**
  - 与普通队列的区别在于tail和head节点声明为 <u>**volatile**</u>
  - **CAS**算法将入队节点设置成尾节点的next节点，不成功则重试。

- **java.util.concurrent.CopyOnWriteArrayList**
  - 写操作都会加锁	
  - 每次写操作（add or remove）都要copy一个副本，在副本的基础上修改后改变array引用
  - 适合读多写少
- **Vector**
  - 方法都加了synchronized锁



### 2. HashMap

#### 为什么扩容是原来的2倍

- HashMap是用hash值来处理冲突的，因此，在存放每个entry时，要先利用它的hash值来计算出在底层数组相应的位置，计算公式是：hash & (n-1)。

- 因此，扩容成原来的2倍，能够保证 n-1 是个前面为0，后面都是1的值，这样 hash & (n-1) 就会保留hash后面部分的值，而舍去前面部分的值。这样的好处是：

  - 保证计算得到的位置在 capacity 内

  - hash & (n-1) = hash % n

    

#### 开放地址法

1. 二次探测
   - 比如：(hash+2i) % n
2. 线性探测
   - 冲突了就线性找



#### 扩容机制

HashMap底层是数组+链表或者红黑树

JDK7，数组初始容量为16，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

JDK8，HashMap是懒加载，数组初始容量为0，当put第一个元素时，创建初始容量16的数组，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

- 当链表元素 > 8且哈希表长度 > 64时，则会转变成红黑树
- 当空间不足时，扩容成原来的2倍。



#### HashMap中扰动函数的作用 ？

```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

扰动函数就是解决碰撞问题。否则就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。



#### HashMap & ConcurrentHashMap

- HashMap是线程不安全的
- ConcurrentHashMap是线程安全的，并且继承了ReentrantLock类。它将底层大数组划分成若干的segment，再匹配到要存入的segment后，用synchronized进行上锁，然后再进行对应的操作。



#### HashMap & HashTable

- HashMap是线程不安全的，并且key和value都可以为null。它是Map接口的实现类，效率较高。
- HashTable是线程安全的，它的方法都是synchronized修饰的，key和value都不能为null。



#### SynchronizedMap

java.util.concurrent.synchronizedMap(new Map<>()；用来给一个map对象上锁。



#### HashMap是否线程安全？有哪些安全的实现

不是线程安全的。

- **HashTable**：给每个方法都上了synchronized锁来实现线程安全。性能较差。

- java.util.concurrent.**ConcurrentHashMap**，通过ReentrantLock来实现线程安全的。
- Collections.**synchronizedHashMap**(new HashMap<>());，也是给传入的HashMap对象加synchronzied锁实现



### 3. ConcurrentHashMap

#### JDK7

- JDK 7 的ConcurrentHashMap采用的是**分段锁**的方法。分段锁对象Segment继承于ReentrantLock类
- 分段锁Segment对象里面保存的是HashEntry数组，该数组用来存放元素。
- HashEntry中的value和next指针都是viotile类型。

分段锁Segment

![image-20220709153724027](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537104.png)

![image-20220709153734935](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537021.png)



存放元素的 HashEntry数组

![image-20220709153748002](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537087.png)



- put

  ![image-20220709153800104](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538211.png)

  1. 调用ReentrantLock的 `tryLock()` 方法，尝试获取对象锁。
     - 如果没有获取到对象锁，则调用 `scanAndLockForPut()` 方法去尝试获取对象锁
  2. 拿到锁以后，那么就执行类似HashMap的put方法。
  3. 但是插入元素是用的**头插法**。



**scanAndLockForPut**：实现了类似自旋锁的功能。会设置一个重试次数，然后不断尝试tryLock()，并且这个重试次数会自增。

- 如果要存放的对应HashEntry位置为空，那么就创建新的节点。
- 如果key相同，那就不断尝试tryLock获取锁，如果重试次数大于最大重试次数，那就调用Lock()方法去获取锁。
- 如果lock()方法也不能获取锁，那么线程堵塞等待。
- 如果循环期间，HashEntry被改动过，那么重试次数置为-1，重新开始重试

![image-20220709153813132](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538220.png)



#### JDK8

![image-20220709153828742](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538811.png)



- put（**CAS + synchronized**）

  ```java
      final V putVal(K key, V value, boolean onlyIfAbsent) {
          // 1.如果key或者value为null，抛出异常
          if (key == null || value == null) throw new NullPointerException();
          // 2.获取hash值
          int hash = spread(key.hashCode());
          int binCount = 0;
          for (Node<K,V>[] tab = table;;) {
              Node<K,V> f; int n, i, fh;
              // 3.table为空，初始化
              if (tab == null || (n = tab.length) == 0)
                  tab = initTable();
              // 4.如果对应的位置没有元素，则调用乐观锁CAS方法插入元素
              else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                  if (casTabAt(tab, i, null,
                               new Node<K,V>(hash, key, value, null)))
                      break;                   // no lock when adding to empty bin
              }
              // 5.如果对应位置上的元素hash值为-1，MOVED，说明有线程正在进行扩容，则帮忙一起扩容
              else if ((fh = f.hash) == MOVED)
                  tab = helpTransfer(tab, f);
              else {
                  V oldVal = null;
                  // 6.否则，加synchronzied锁
                  synchronized (f) {
                      if (tabAt(tab, i) == f) {
                          if (fh >= 0) {
                              binCount = 1;
                              // 7.1 对于链表结构，进行循环查找，找到相应的值，并且替换value
                              for (Node<K,V> e = f;; ++binCount) {
                                  K ek;
                                  if (e.hash == hash &&
                                      ((ek = e.key) == key ||
                                       (ek != null && key.equals(ek)))) {
                                      oldVal = e.val;
                                      if (!onlyIfAbsent)
                                          e.val = value;
                                      break;
                                  }
                                  Node<K,V> pred = e;
                                  if ((e = e.next) == null) {
                                      pred.next = new Node<K,V>(hash, key,
                                                                value, null);
                                      break;
                                  }
                              }
                          }
                          // 7.2 如果位置上节点是红黑树节点，则插入到树中
                          else if (f instanceof TreeBin) {
                              Node<K,V> p;
                              binCount = 2;
                              if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                             value)) != null) {
                                  oldVal = p.val;
                                  if (!onlyIfAbsent)
                                      p.val = value;
                              }
                          }
                      }
                  }
                  // 8.如果链表上的节点大于8，则尝试扩容
                  if (binCount != 0) {
                      if (binCount >= TREEIFY_THRESHOLD)
                          treeifyBin(tab, i);
                      if (oldVal != null)
                          return oldVal;
                      break;
                  }
              }
          }
          addCount(1L, binCount);
          return null;
      }
  ```

  



### 4. String, StringBuffer, StringBuilder

1. String是不可变的，每次对String的修改，都是在常量池中生成一个新的String，然后将指针指向这个新的String。

2. StringBuffer和StringBuilder都是可变字符串。

   - StringBuffer是线程安全的，每次append()都会上锁，同步锁是new出来的StringBuilder对象。
   - StringBuilder是线程不安全的，大多数情况下StringBuilder要比StringBuffer快。

3. JDK5之前，String连加会被优化成StringBuffer，**JDK5之后，优化成StringBuilder。**

   ```java
   public String concatString(String s1, String s2, String s3) {
   	return s1 + s2 + s3;
   }
   ```

   ```java
   public String concatString(String s1, String s2, String s3) {
       StringBuffer sb = new StringBuffer();
       sb.append(s1);
       sb.append(s2);
       sb.append(s3);
       return sb.toString();
   }
   ```

   

### 5. equals 和 == 的区别

1. ==：
   - 基本数据类型：==比较的是值是否相等。
   - 引用数据类型：==比较的是地址值是否相等。
2. equals：
   - 比较的是对象的地址是否相等。Object类中，equals的定义就是比较两个Object对象的地址值是否一样。
   - 但是String，Date，File和包装类中的equals方法被重写过，比较的是两者的内容是否相等。



### 6.为什么要重写 hashcode 和 equals 方法

在HashMap存储自定义的类的时候，需要重写hashcode和equals方法。

- 比如，存放id都为1的两个对象k1和k2。如果不重写hashcode和equals方法，在hashmap中put完k1后，如果get(k2)，会得到null，尽管他们的id相同。
- 因为自定义类没有重写hashcode，他们默认会以地址值作为自己的hash值，所以，k1和k2会放在不一样的位置。因此要重写。
- 如果没有重写equals方法，自定义类会使用Object类的equals方法，比较k1和k2的地址值是否相同，而k1和k2的地址值是不同的，但是id相同，因此要重写equals方法。



### 7.请你解释为什么会出现4.0-3.6=0.40000001这种现象？

《Java核心技术 卷I》：

因为二进制无法精确地表示十进制的数。在进行浮点型4.0-3.6的时候，需要先从十进制转变成二进制，再进行计算，这里面就会产生一些误差。这就跟十进制没法表示出1/3一样。

如果想计算过程中没有差错，应该用**BigDecimal**类。



### 8.Java的异常机制





### 9.String

#### String是如何实现它不可变的？ 

>  如果说：定义String时，实际上是将字符串赋值给一个char[]数组，而String源码中，这个char[]被修饰成了final类型。所以String是不可变的，那是不准确的。因为final修饰的引用类型，只能保证该引用类型指向的地址不可变，但是对象内的内容是可以改变的。
>
> - 不过final可以保证String不能被继承修改value
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/4376cf372fb0445692353ed939eb78c9.png)
>
> - 可以看出修改数组中的值是可以的，但是让当前变量指向新数组时会报错。

**综上所述，String不能被改变是因为private和final的修饰。而且String也没有提供可以修改字符数组的api，外界不可访问value[]，自然String就不能被修改。**

- 当给String赋新值时，会创建新的引用指向常量池的另一个空间。

- 如果是通过new String的方式创建的字符串，会在堆中创建一个字符串对象，栈中的引用指向堆中的字符串对象，然后堆中的字符串对象指向常量池里的字符串。

  ![image-20220715172829860](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151728974.png)



#### 为什么要设置String为不可变对象 ?

1. 安全性：如果很多地方引用了同一个字符串，而且字符串可变的话，此时修改了一下字符串的内容，那这些引用了这个字符串的值都不对了。
2. 节省空间：内容相同的字符串可以指向常量池的同一个空间，从而节省了空间。
3. 线程安全：多个线程修改字符串，都是创建新的字符串，不会造成线程安全问题。



### 10.重写和重载的区别

- 重写：Override

  - 子类继承父类时，可以对父类的方法进行重写。
  - 子类重写的方法必须和父类有相同的方法名称、参数列表。
  - 重写的方法的返回类型要 <= 父类方法的返回类型。
  - 重写方法抛出的异常要 <= 父类方法抛出的异常。
  - 重写方法的访问权限要 >= 父类的访问权限
    - 父类private方法不能被重写。

- 重载：Overload

  - 重载是在一个类中。

  - 重载的方法和原方法的方法名相同，但参数列表必须不同

    ![image-20220715174152658](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151741720.png)

  - 重载的方法可以和原方法有不同的返回值。

    ![image-20220715174306627](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151743685.png)



### 11.深拷贝和浅拷贝区别

- 引用数据类型：
  - 浅拷贝只是复制引用指针，而没有复制被引用的对象。
  - 深拷贝不仅会复制引用指针，而且会复制一份完整的对象。

#### Object.clone()方法属于浅拷贝还是深拷贝？

浅拷贝。因此如果要使用深拷贝，需要重写clone方法



### 12.Java三大特性

1. 封装
   - 类的成员变量私有，通过对外暴露方法来设置和获得变量的值。
2. 继承
   - 子类可以继承父类。子类可以通过重写父类的方法来实现父类功能的拓展。
   - 类可以实现接口。
3. 多态
   - 编译看左边，运行看右边。



### 13.Object的方法

1. `getClass()`：获得运行时类型。返回Class对象。

2. `equals()`：

   ```java
   public boolean equals(Object obj) {
           return (this == obj);
       }
   ```

   判断两个对象的地址值是否一样。

3. `clone()`：实现浅拷贝。
4. `toString()`：返回 类名+hashCode的16进制数字。
5. `wait()`：让当前线程进入等待状态
6. `notify()`：唤醒在此对象锁上等待的某个线程（随机的某一个）。
7. `notifyAll()`：唤醒在此对象锁上等待的所有线程。
8. `finalize()`：GC之前调用，在对象二次标记前可以通过这个方法拯救自己。



### 14.接口和抽象类的区别



### 15.反射

1. 反射是动态语言的关键。每个类在加载之后，就会在堆中生成一个Class类型的对象。这个对象保存了类的结构信息。



### 16.replace() 和 replaceAll() 的区别

- replace(char oldChar, char newChar): 用newChar替换原String中所有oldChar。
- replaceAll(String reg, String replacement)：用replacement代替正则表达式reg匹配的字符串。



### 17.抽象类

#### 抽象类和普通类的区别

1. 抽象类是abstract修饰的类。普通类没有修饰。
2. 抽象类没有具体的实例，而普通类可以生成实例。
3. 包含抽象方法的类一定是抽象类，而普通类不含有抽象方法。

#### 抽象类和接口的区别

1. 抽象类是abstract修饰的类，而接口是interface。
2. 抽象类中可以含有非抽象的方法，而接口中只能含有非抽象的方法。
3. 抽象类可以有构造方法，而接口不能有构造方法。
4. 子类继承抽象类，子类实现接口。
5. 一个类可以实现多个接口，但只能继承于一个抽象类。



### 18.说说面向对象的理解



## JVM





## 多线程

### 1.进程和线程



### 2.notify和notifyAll

等待池：对象调用了线程A的wait方法，线程A就会释放对象的锁，并且进入等待池，在等待池中，不会去竞争对象的锁。

- notify( )：唤醒线程具有随机性。随机选择等待池的一个线程去唤醒。
- notifyAll( )：唤醒等待池中所有线程。





## 锁

### 1.死锁

#### 死锁演示代码

```java
public class DeadLockedTest {

    public static void main(String[] args) {
        DeadLock t1 = new DeadLock();
        DeadLock t2 = new DeadLock();
        t1.flag = true;
        new Thread(t1).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t2.flag = false;
        new Thread(t2).start();
    }
}

class DeadLock implements Runnable {

    public static boolean flag = true;

    static Object o1 = new Object();
    static Object o2 = new Object();

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "__flag__" + flag);
        if(flag) {
            synchronized (o1) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                }
            }
        }

        if(!flag) {
            synchronized (o2) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                }
            }
        }
    }
}


```

#### 什么是死锁

多个线程因为争夺资源而陷入僵局，若无外力作用，这些线程会保持僵持状态。



#### 死锁的四个条件

1. **互斥条件**：进程所占有的资源不允许其他进程访问，若其他进程访问该资源，就必须等待，直到占有该资源的进程使用完成后释放。
2. **请求和保持条件**：进程获得一定资源后，又去请求其他资源，而请求的资源被其他进程占用，此请求被阻塞，而占有的资源仍然保持不释放。
3. **不可剥夺条件**：进程已获得的资源，不可被剥夺，只能在使用后自己释放
4. **循环等待条件**：进程发生死锁后，必然存在一个进程--资源的环形链。{P1, P2, ..., Pn}，P1等待P2的资源，P2等待P3的资源.....Pn等待P1的资源。



#### 如何避免死锁

破坏四个必要条件之一即可避免死锁。

1. 破坏请求和保持条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待。
2. 破坏不可剥夺条件：一个进程占有资源后，去请求另一个资源失败后，就放弃占有的资源。
3. 打破循环等待条件：资源有序分配，所有进程按序请求资源。

##### 银行家算法

- 可利用的资源总量
- 每个进程的最大需求资源
- 已分配的资源
- 仍需要的资源

![image-20220712111051281](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207121110411.png)

1. 当一个进程申请资源时，操作系统判断当前资源能否满足
   - 可以满足
     - 判断把进程申请的资源分配给进程后，剩余的资源能否满足进程队列的某个进程执行完毕
       - 能满足，假设回收可以完成执行的进程资源，然后依次判断，直到所有进程都能执行完毕，则安全
       - 不能满足，不安全
   - 不能满足，不安全





### 2.AbstractQueuedSynchronizer（AQS）

- 队列同步器，用于**构建锁**和其他同步组件
- 基于**模板方法**
- 使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作



### 3.锁膨胀机制

无锁—>偏向锁—>轻量级锁—>重量级锁

1. 无锁：

2. 偏向锁：为了在没有线程竞争的情况，减少对轻量级锁的使用。如果锁总是被一个线程获取，那就认为不存在多线程竞争的环境，后续这个线程就可以自动获取锁。

   当虚拟机开启偏向模式后，每当一个锁对象被线程获取，那么虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。持有偏向锁的线程每次进入相关同步块时，虚拟机都不再执行同步操作。

   一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。线程不会主动释放锁，只有遇到其他线程竞争偏向锁时，线程才会释放锁。

3. 轻量级锁：轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。

4. 重量级锁：一个线程获得锁以后，其他等待获取这个锁的线程都会处于阻塞状态。

**锁膨胀过程**：

- 锁对象创建后，默认没有线程竞争。此时，线程A获得锁对象，则锁偏向于线程A，虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。
- 如果此时，出现线程b竞争该锁对象的情况，则会等待全局安全点后，暂停持有偏向锁的线程A，然后检查线程A是否还活着。
  - 如果线程A不处于活动状态，则线程A设置为无锁状态，锁偏向于线程B。
  - 如果线程A仍处于活动状态，则说明产生了锁竞争。升级成为轻量级锁。

- 轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。



### 4.线程安全的实现方式

![image-20220709135312191](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091353254.png)

#### ThreadLocal

![image-20220709135252778](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091352841.png)

#### 定义

线程变量。线程私有的本地变量，它对其他线程是隔离的，其他线程不能访问到该线程的线程本地变量。

线程会维护一个ThreadLocalMap结构，key是ThreadLocalHashCode，即一个ThreadLocal对象，value是本地变量的值，而访问入口就是这个ThreadLocal对象。

#### 使用场景

数据库连接管理。一个线程维护一个连接，线程会保存连接副本，该连接副本就是线程的一个本地变量，其他线程不可以访问该连接副本。

#### 可能出现的问题

内存泄漏问题。线程池中得线程在使用完后，回归到线程池，因为该线程没有被回收掉，所以他引用的ThreadLocal对象也不会被回收掉。这种情况下，如果没有把该线程的ThreadLocal对象remove()掉，那该ThreadLocal对象会一直存在，占用着内存。

解决：线程池的线程任务结束前，手动remove掉ThreadLocal对象。



### 5.synchronized和lock的区别

我们常称synchronized为隐式锁 ，lock为显式锁

1. 实现不同
   - synchronized是JVM层面上的实现
   - Lock是JDK5以后的API接口
2. 



#### 什么时候用synchronized什么时候用ReentrantLock



### 6.volatile和synchronized区别？



## Spring

### 1.bean的生命周期 



### 2.Spring中有哪些重要的扩展点 



### 3.BeanFactory和ApplicationContext的区别是什么？ 



### 4.BeanFactory和FactoryBean有什么区别 



### 5.Spring的锁



### 6.Spring的事务



## Nginx

### 1.Nginx的功能

1. 负载均衡
2. 反向代理
3. 动静分离



### 2.负载均衡五种策略

1. **轮询**（默认）

   - 按照请求顺序逐一分配后端服务器
   - 如果后端服务器down掉，可以自动剔除

   ```nginx
   upstream backserver {
       server 192.168.0.14;
       server 192.168.0.15;
   }
   ```

   

2. **带weight的轮询**

   - weight和后端服务器的访问率成正比
   - 适合后端服务器性能不均的情况

   ```nginx
   upstream backserver {
       server 192.168.0.14 weight=3;
       server 192.168.0.15 weight=7;
   }
   ```

   

> 1和2的问题：
>
> - 如果一个用户在一个后端服务器上登录过了，二次请求的时候，被分配到另一个服务器，这时候其登录信息丢失了，就需要重新登录

​	

3. **ip_hash**

   - 通过hash算法，每次把相同的用户定位到同一个后端服务器上去

   ```java
   upstream backserver {
       ip_hash;
       server 192.168.0.14:88;
       server 192.168.0.15:80;
   }
   ```



**第三方策略：**

4. **fair**

   - 按照响应时间来分配后端服务器，响应时间短的优先分配

   ```nginx
   upstream backserver {
       server server1;
       server server2;
       fair;
   }
   ```

   

5. **url_hash**

   - 按照url的结果来分配后端服务器

   ```nginx
   upstream backserver {
       server squid1:3128;
       server squid2:3128;
       hash $request_uri;
       hash_method crc32;
   }
   ```

   



## 设计模式篇

### 1.单例模式

也是staic的经典用例

```java
/*
* 饿汉式单例模式
* */
class Bank1 {
    private Bank1() {}

    private static Bank1 instance = new Bank1();

    public static Bank1 getInstance() {
        return instance;
    }
}

/*
* 懒汉式单例模式
* */
class Bank2 {
    private Bank2() {}

    private static Bank2 instance = null;

    public static Bank2 getInstance() {
        if(Objects.isNull(instance)) {
            return new Bank2();
        } else {
            return instance;
        }
    }
}
```

1. **饿汉式**

   优点：线程安全

   缺点：一开始就创建好实例，占用内存。

2. **懒汉式**

   优点：用的时候才创建实例

   缺点：线程不安全

线程安全的懒汉式：

```java
/*
 * 线性安全的懒汉式单例模式
 * */
class Bank3 {
    private Bank3() {}

    private static Bank3 instance = null;

    public static Bank3 getInstance() {
        synchronized (Bank3.class) {
            if(Objects.isNull(instance)) {
                return new Bank3();
            } else {
                return instance;
            }
        }
    }
}
```



#### 双检测机制的单例模式

```java
class Singleton {
    private Singleton() {}

    private volatile static Singleton instance = null;

    public static Singleton getInstance() {
        if(instance  == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

##### 为什么要用双检测机制

因为这样可以即保证能正确的生成单例，又保证了性能。因为只在第一次创建实例的时候加同步锁，之后不用再同步。

##### 单例为什么要用Violatile修饰？

**指令重排：JVM对于代码执行顺序会有优化，因此，代码执行不一定是按照代码编写的顺序。**

创建实例的过程：

1. 开辟内存空间
2. 实例初始化
3. 创建指针指向指定的内存空间

但是，jvm可能会把代码优化成：1——>3——>2

这时候，如果有一个线程在执行1——>3的时候，另一个线程读取instance实例。此时，instance已经指向了一个内存空间，所以就返回了这个instance，这会导致错误。

而violatile实例有两个作用：

- 可见性：violatile修饰的变量对于每个线程都是可见的。
- 有序性：告诉虚拟机，这段代码不需要优化，而是按照代码顺序执行。这样可以避免上述说到的问题。



### 2.工厂模式



### 3. 装饰模式和代理模式区别







## 计网篇

### 1. TCP

TCP提供可靠的，点对点，全双工连接。 

- 可靠的
- 点对点：只能one host to one host
- 全双工：连接后，上层应用层host A和host B可以互相传输data。

#### 三次握手

![image-20220709153545252](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091535317.png)

1. Client发送报文段给Server来请求连接，设置标志位syn为1，sequence number为随机一个值x。
2. Server收到Client发来的报文后，设置标志位SYN和ACK都设置为1，acknowledege number为x+1，sequence number为随机值y
3. Client收到Server发来的报文后，检查标志位ACK是否1，然后设置回复报文ACK为1，seq为 x+1, acknowledege number为 y+1。此时，Server收到报文后，连接建立。

#### 为什么是三次握手？可不可以两次

因为client和server之间的传输信道是不可靠的，因此，存在消息丢失的可能性。

首先要说，3次握手只是理论上保持可靠传输的最小值。如果只有两次握手，那么可能会出现一种情况：

1. client发送连接建立请求，结果因为延迟，很晚才到达server，而在此期间，client已经取消了连接。
2. server收到连接请求后，回复确认给client，并且建立了连接。
3. 然而，此时client已经取消了连接，而server却建立了连接，并苦苦等待client发信息过来，这就造成了server的资源浪费。



#### 四次挥手

![image-20220709153558582](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091535686.png)

1. client主动断开连接，发送FIN=1, sequence number = u，表示自己已经停止发送数据。
2. server收到client发来的报文段后，回复ACK=1表示确认收到，seq=k，ack=u+1。然后继续发送数据。
3. server发完报文后，发送FIN=1，ACK=1，seq=w，ack=u+1，表示自己停止发送数据
4. client收到报文后，发送ACK=1，seq=u+1，ack=w+1给server。
5. server说到ACK报文后，关闭连接。Client 进行time_wait等待（2个最长报文段寿命）后，关闭连接。

#### TIME_WAIT

**主动关闭方**在第四次挥手发送ACK确认后，需要有一个TIME_WAIT等待时间。因为，

1. 主动关闭方无法确认该ACK报文对方是是否已经收到。如果该报文段丢失，对方没有收到，而主动关闭方没有进行TIME_WAIT等待就关闭了连接，那么对方发送重新发送FIN关闭请求时，主动关闭方由于已经关闭了连接而无法收到该报文，这样会导致对方没法正常关闭连接。
2. 防止上一次连接中一些迷路的包发送了过来。

因此，TIME_WAIT是主动关闭方确保对方已经收到第四次挥手确认报文而存在的。

> TIME_WAIT一般是2MSL （Maximum Segment Lifetime）
>
> - RFC 793 文档将 MSL 的时间设置为 120 秒，即两分钟，然而这并不是一个经过严密推断的数值，而是工程上的选择，如果根据服务历史上的经验要求我们改变操作系统的设置，也是没有任何问题的；实际上，较早版本的 Linux 就开始将 `TIME_WAIT` 的等待时间 [`TCP_TIMEWAIT_LEN`](https://github.com/torvalds/linux/blob/bd2463ac7d7ec51d432f23bf0e893fb371a908cd/include/net/tcp.h#L121) 设置成 60 秒，以便更快地复用 TCP 连接资源：

#### CLOSE_WAIT

**被动关闭方**在收到主动关闭方发来的FIN连接关闭请求后，回复ACK报文，之后就进行CLOSE_WAIT状态。等待一段时间后，发送FIN关闭请求给主动关闭方。



### 2.HTTP

#### HTTP1.0

浏览器的每一次请求，都需要和服务器建立一个TCP连接。开销很大。影响服务器的性能。

#### HTTP1.1

1. 持久连接：TCP连接默认不关闭，可以与多个请求共用
2. 管道机制：同一个浏览器和服务器的多次请求可以在同一个TCP连接中，进行通信。
   - http请求头中加入`Connection: keep-alive`来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上`Connection: keep-alive`

3. 分块传输编码：服务器每生成一个数据块，就传输一个数据，用流传输代替缓存传输。
4. 端口是80

- 缺点：
  1. TCP连接中的数据，必须按序到达。服务器只有处理完一个请求后，才可以继续处理下一个请求。这会带来堵塞的问题。

#### HTTP2

1. 支持多路复用：浏览器和服务器之间可以同时发送多个请求和回复，不要求TCP连接中的数据按序到达。
2. 报头压缩：HTTP2队头部信息进行了信息压缩，减少了头部信息。
3. HTTP2允许服务器未经请求，便向浏览器发送数据。

#### HTTPS

HTTPS是HTTP和TCP之间，增加了一条SSL加密层，端口是443。

![image-20220709153614891](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091536947.png)

1. 浏览器发送HTTPS请求给服务器。
2. 服务器收到请求以后，生成公钥和私钥，把公钥和证书一起发给浏览器。
3. 浏览器校验证书后，利用公钥给密钥加密。并且把加密好的密钥发送给服务器。
4. 服务器拿到密钥后，用私钥进行解密。
5. 然后浏览器和服务器之间就建立了一条加密通道，数据都通过这个加密通道进行传输。

#### HTTP3

是最新的协议，利用UDP+quic代替TCP+SSL/TLS层。

![image-20220709153635599](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091536681.png)

### 3.OSI七层模型



### 4.Session和Cookie

- **Cookie**：
  - Http是无状态协议（HTTP协议**不具备保存之前发送过的请求或响应的功能**），服务器无法得知浏览器的信息。因此，在一个浏览器请求服务器后，会根据浏览器身份生成一个cookie，然后相应给浏览器。之后，浏览器请求的时候，都要带上这个cookie。这样，服务器就可以通过cookie确认身份了。
  - 一般是4k

- **Session**：
  - 服务器保存客户端的信息。访问服务端的客户端信息都会被服务器记录下来。这就是Session。


> 比如gulimall项目中，用户登录成功后，member模块会将后台用户的详细信息返回给auth-server模块，该详细信息序列化成data后，session中保存键值对{userLogin, data}。然后该键值对返回给浏览器，保存为cookie中。



### 5.Session和token

session和token都是用来保持会话的

- session基于cookie
- token：浏览器登录后，服务器根据用户信息和哈希值，通过密钥进行加密成token，然后直接传给客户端，客户每次请求再携带过来给服务端。服务端直接根据token里面的数据信息进行校验。



### 6.常见状态码

- 200 成功
- 400 错误请求，服务器不知道浏览器的请求语法
- 401 未授权
- 403 forbidden，禁止
- 404 未查到页面
- 500 服务器内部错误



### 7.请求头有什么内容

	1. 请求类型：我们常见的请求类型有Get和Post两种请求，而这个信息在HTTP请求报文中的地一行即请求中就可以得到；
	1. 请求地址：请求地址告诉服务端当前请求来自哪里，例如"/"表示的是服务器根目录，对一个静态网站而言，如果存在index.html

　　　　　　　　则指向该网页；对一个动态网站而已，如果存在index.php则它指向该网页。

3. 请求参数：客户端和服务器的通信最终是要落实到具体数据的传递上来的，所以通过请求报文我们能够获得客户端传递的参数

　　　　　　　　并对其进行处理，通常Get类型参数在请求行、而Post类型参数在消息体中。

4. 请求约束：我们把1、2、3是通信核心要素，那么接下来这些我们可以称其为细节要素。

5. 请求报文



### 8.  get和post的区别



## 操作系统

### 1.用户态和内核态的区别



### 2.fork()作用



### 3.Select poll epoll的区别



### 4.虚拟内存作用？ 内存分页的作用？



### 5. 缺页异常的介绍



### 6.OOM问题和 StackOverFlow的区别





## 算法



### KMP

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201052782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

##### 算法思想

利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置

接下来我们自己来发现j的移动规律：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201107203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

如图：C和B不匹配了，我们要把j移动到哪？应该是第2位。为什么？因为前面AB相同：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201112929.png)



##### 算法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201148169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201234972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

- 关键是求出每个位置处j对应的k，有了k，就知道当某位置处的j和原字符串不匹配时，要将j移动几个位置：next[]
- 当`p[j]==p[k]`时，`next[j+1]==next[j]+1`，所以`k=next[k]`
  - 现在j所在的位置是C，C不匹配，移动到B的位置，D不匹配移动到C的位置

```java
public static int[] getNext(String pattern) {

    char[] p = pattern.toCharArray();
    int[] next = new int[p.length];
    next[0] = -1; // 如果 pattern 第一位不匹配，i指针要后移，所以初始化为-1
    int j = 0;
    int k = -1;

    while (j < p.length - 1) {
       if (k == -1 || p[j] == p[k]) {
           next[++j] = ++k;
       } else {
           k = next[k];
       }
    }

    return next;
}
```



### 雪花算法





## Linux

### 常用指令

#### 查看占用端口

lsof -i:80



### apt

apt-get install

apt-get remove

apt-get purge：会把配置文件也删除







































