# 面试题

2、Java集合框架了解哪些？总体架构？常用的一些类的特性说一说 

  

  10、分段锁是用的什么锁？ 

  11、Java中的锁你了解多少？ 

4，mysql索引
5，redis的持久化，aof和rdb
6，aof重写



## Java篇

### 1. ArrayList和LinkedList 的区别？

1. 底层实现不同：他们的底层实现不一样。ArrayList 底层实现是数组，而 LinkedList 底层是双向循环链表。
2. 适用场景不同：
   - ArrayList适合快速读取元素的场景。然而对于元素的插入和删除，需要大量的移动其他的元素。
   - 而LinkedList适合插入和删除频繁的场景。但是对于指定位置元素的查询，需要对链表进行遍历。
     - LRU的实现。
3. 空间占用不同：
   - ArrayList底层是数组，而LinkedList除了要保存节点元素外，还要保存pre和next指针，因此更占空间。



#### ArrayList和LinkedList插入元素时，谁的效率高？

添加元素相关的操作时不说场景的情况下，说不定谁的效率高。

#### ArrayList和LinkedList是否线程安全？有哪些安全的？

不是线程安全的。

- **ArrayList**：比如现在有线程A和线程B同时想要在0的位置add元素，此时ArrayList的size为0。
  - A线程在0位置添加元素后，在size++之前，因为一些原因被阻塞。
  - B线程读取到size仍为0，则在0位置添加元素后，size++。
  - A线程再让size++。
  - 最终，ArrayList里只有1一个元素，size却为2。

- **LinkedList**：比如现在有线程A和线程B同时想要在链表末尾add元素。
  - 线程A获取到链表的last节点，并且指定l=last，此时，A因为一些原因被堵塞。
  - 线程B正常地在链表末尾添加新的节点。
  - 线程A恢复运行，在l后面添加新元素。
  - 这时候，线程B添加的新节点实际上已经访问不到了。

**有哪些线程安全的**：

- 方法**Collections.synchronizedList(List list)**;
  - 当传入的 list 是 ArrayList 时，返回 SynchronizedRandomAccessList 对象；传入 LinkedList 时，返回 SynchronizedList 对象
  - get, set, add 等操作都加了 `sychronized(mutex)` 对象锁，再将操作委托给最初传入的 list。

- **ConcurrentLinkedQueue**
  - 与普通队列的区别在于tail和head节点声明为 <u>**volatile**</u>
  - **CAS**算法将入队节点设置成尾节点的next节点，不成功则重试。

- **java.util.concurrent.CopyOnWriteArrayList**
  - 写操作都会加锁	
  - 每次写操作（add or remove）都要copy一个副本，在副本的基础上修改后改变array引用
  - 适合读多写少
- **Vector**
  - 方法都加了synchronized锁



### 2. HashMap

#### 为什么扩容是原来的2倍

- HashMap是用hash值来处理冲突的，因此，在存放每个entry时，要先利用它的hash值来计算出在底层数组相应的位置，计算公式是：hash & (n-1)。

- 因此，扩容成原来的2倍，能够保证 n-1 是个前面为0，后面都是1的值，这样 hash & (n-1) 就会保留hash后面部分的值，而舍去前面部分的值。这样的好处是：

  - 保证计算得到的位置在 capacity 内

  - hash & (n-1) = hash % n

    

#### 开放地址法

1. 二次探测
   - 比如：(hash+2i) % n
2. 线性探测
   - 冲突了就线性找



#### 扩容机制

HashMap底层是数组+链表或者红黑树

JDK7，数组初始容量为16，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

JDK8，HashMap是懒加载，数组初始容量为0，当put第一个元素时，创建初始容量16的数组，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

- 当链表元素 > 8且哈希表长度 > 64时，则会转变成红黑树
- 当空间不足时，扩容成原来的2倍。



#### HashMap中扰动函数的作用 ？

```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

扰动函数就是解决碰撞问题。否则就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。



#### HashMap & ConcurrentHashMap

- HashMap是线程不安全的
- ConcurrentHashMap是线程安全的，并且继承了ReentrantLock类。它将底层大数组划分成若干的segment，再匹配到要存入的segment后，用synchronized进行上锁，然后再进行对应的操作。



#### HashMap & HashTable

- HashMap是线程不安全的，并且key和value都可以为null。它是Map接口的实现类，效率较高。
- HashTable是线程安全的，它的方法都是synchronized修饰的，key和value都不能为null。



#### SynchronizedMap

java.util.concurrent.synchronizedMap(new Map<>()；用来给一个map对象上锁。



#### HashMap是否线程安全？有哪些安全的实现

不是线程安全的。

- **HashTable**：给每个方法都上了synchronized锁来实现线程安全。性能较差。

- java.util.concurrent.**ConcurrentHashMap**，通过ReentrantLock来实现线程安全的。
- Collections.**synchronizedHashMap**(new HashMap<>());，也是给传入的HashMap对象加synchronzied锁实现



### 3. ConcurrentHashMap

#### JDK7

- JDK 7 的ConcurrentHashMap采用的是**分段锁**的方法。分段锁对象Segment继承于ReentrantLock类
- 分段锁Segment对象里面保存的是HashEntry数组，该数组用来存放元素。
- HashEntry中的value和next指针都是viotile类型。

分段锁Segment

![image-20220709153724027](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537104.png)

![image-20220709153734935](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537021.png)



存放元素的 HashEntry数组

![image-20220709153748002](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091537087.png)



- put

  ![image-20220709153800104](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538211.png)

  1. 调用ReentrantLock的 `tryLock()` 方法，尝试获取对象锁。
     - 如果没有获取到对象锁，则调用 `scanAndLockForPut()` 方法去尝试获取对象锁
  2. 拿到锁以后，那么就执行类似HashMap的put方法。
  3. 但是插入元素是用的**头插法**。



**scanAndLockForPut**：实现了类似自旋锁的功能。会设置一个重试次数，然后不断尝试tryLock()，并且这个重试次数会自增。

- 如果要存放的对应HashEntry位置为空，那么就创建新的节点。
- 如果key相同，那就不断尝试tryLock获取锁，如果重试次数大于最大重试次数，那就调用Lock()方法去获取锁。
- 如果lock()方法也不能获取锁，那么线程堵塞等待。
- 如果循环期间，HashEntry被改动过，那么重试次数置为-1，重新开始重试

![image-20220709153813132](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538220.png)



#### JDK8

![image-20220709153828742](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091538811.png)



- put（**CAS + synchronized**）

  ```java
      final V putVal(K key, V value, boolean onlyIfAbsent) {
          // 1.如果key或者value为null，抛出异常
          if (key == null || value == null) throw new NullPointerException();
          // 2.获取hash值
          int hash = spread(key.hashCode());
          int binCount = 0;
          for (Node<K,V>[] tab = table;;) {
              Node<K,V> f; int n, i, fh;
              // 3.table为空，初始化
              if (tab == null || (n = tab.length) == 0)
                  tab = initTable();
              // 4.如果对应的位置没有元素，则调用乐观锁CAS方法插入元素
              else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                  if (casTabAt(tab, i, null,
                               new Node<K,V>(hash, key, value, null)))
                      break;                   // no lock when adding to empty bin
              }
              // 5.如果对应位置上的元素hash值为-1，MOVED，说明有线程正在进行扩容，则帮忙一起扩容
              else if ((fh = f.hash) == MOVED)
                  tab = helpTransfer(tab, f);
              else {
                  V oldVal = null;
                  // 6.否则，加synchronzied锁
                  synchronized (f) {
                      if (tabAt(tab, i) == f) {
                          if (fh >= 0) {
                              binCount = 1;
                              // 7.1 对于链表结构，进行循环查找，找到相应的值，并且替换value
                              for (Node<K,V> e = f;; ++binCount) {
                                  K ek;
                                  if (e.hash == hash &&
                                      ((ek = e.key) == key ||
                                       (ek != null && key.equals(ek)))) {
                                      oldVal = e.val;
                                      if (!onlyIfAbsent)
                                          e.val = value;
                                      break;
                                  }
                                  Node<K,V> pred = e;
                                  if ((e = e.next) == null) {
                                      pred.next = new Node<K,V>(hash, key,
                                                                value, null);
                                      break;
                                  }
                              }
                          }
                          // 7.2 如果位置上节点是红黑树节点，则插入到树中
                          else if (f instanceof TreeBin) {
                              Node<K,V> p;
                              binCount = 2;
                              if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                             value)) != null) {
                                  oldVal = p.val;
                                  if (!onlyIfAbsent)
                                      p.val = value;
                              }
                          }
                      }
                  }
                  // 8.如果链表上的节点大于8，则尝试扩容
                  if (binCount != 0) {
                      if (binCount >= TREEIFY_THRESHOLD)
                          treeifyBin(tab, i);
                      if (oldVal != null)
                          return oldVal;
                      break;
                  }
              }
          }
          addCount(1L, binCount);
          return null;
      }
  ```

  



### 4. String, StringBuffer, StringBuilder

1. String是不可变的，每次对String的修改，都是在常量池中生成一个新的String，然后将指针指向这个新的String。

2. StringBuffer和StringBuilder都是可变字符串。

   - StringBuffer是线程安全的，每次append()都会上锁，同步锁是new出来的StringBuilder对象。
   - StringBuilder是线程不安全的，大多数情况下StringBuilder要比StringBuffer快。

3. JDK5之前，String连加会被优化成StringBuffer，**JDK5之后，优化成StringBuilder。**

   ```java
   public String concatString(String s1, String s2, String s3) {
   	return s1 + s2 + s3;
   }
   ```

   ```java
   public String concatString(String s1, String s2, String s3) {
       StringBuffer sb = new StringBuffer();
       sb.append(s1);
       sb.append(s2);
       sb.append(s3);
       return sb.toString();
   }
   ```

   

### 5. equals 和 == 的区别

1. ==：
   - 基本数据类型：==比较的是值是否相等。
   - 引用数据类型：==比较的是地址值是否相等。
2. equals：
   - 比较的是对象的地址是否相等。Object类中，equals的定义就是比较两个Object对象的地址值是否一样。
   - 但是String，Date，File和包装类中的equals方法被重写过，比较的是两者的内容是否相等。



### 6.为什么要重写 hashcode 和 equals 方法

在HashMap存储自定义的类的时候，需要重写hashcode和equals方法。

- 比如，存放id都为1的两个对象k1和k2。如果不重写hashcode和equals方法，在hashmap中put完k1后，如果get(k2)，会得到null，尽管他们的id相同。
- 因为自定义类没有重写hashcode，他们默认会以地址值作为自己的hash值，所以，k1和k2会放在不一样的位置。因此要重写。
- 如果没有重写equals方法，自定义类会使用Object类的equals方法，比较k1和k2的地址值是否相同，而k1和k2的地址值是不同的，但是id相同，因此要重写equals方法。



### 7.请你解释为什么会出现4.0-3.6=0.40000001这种现象？

《Java核心技术 卷I》：

因为二进制无法精确地表示十进制的数。在进行浮点型4.0-3.6的时候，需要先从十进制转变成二进制，再进行计算，这里面就会产生一些误差。这就跟十进制没法表示出1/3一样。

如果想计算过程中没有差错，应该用**BigDecimal**类。



### 8.Java的异常机制

![img](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207241152454.webp)

Java 异常机制的基类：Throwable

- **Error**：Java虚拟机无法解决的严重问题。代表运行时出现的严重错误。
  - StackOverFlowError：栈溢出错误
  - OutOfMemoryError：内存溢出错误/堆溢出错误
- **Exception**：程序本身可以捕获并处理的异常
  - **编译时异常** ：该类异常必须被处理，不然编译无法通过
    - IOException
    - ClassNotFindException
  - **运行时异常**：
    - NullPointerException
    - ArrayIndexOutOfBoundsException
    - ClassCastException
    - NumberFormatException



### 9.String

#### String是如何实现它不可变的？ 

>  如果说：定义String时，实际上是将字符串赋值给一个char[]数组，而String源码中，这个char[]被修饰成了final类型。所以String是不可变的，那是不准确的。因为final修饰的引用类型，只能保证该引用类型指向的地址不可变，但是对象内的内容是可以改变的。
>
> - 不过final可以保证String不能被继承修改value
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/4376cf372fb0445692353ed939eb78c9.png)
>
> - 可以看出修改数组中的值是可以的，但是让当前变量指向新数组时会报错。

**综上所述，String不能被改变是因为private和final的修饰。而且String也没有提供可以修改字符数组的api，外界不可访问value[]，自然String就不能被修改。**

- 当给String赋新值时，会创建新的引用指向常量池的另一个空间。

- 如果是通过new String的方式创建的字符串，会在堆中创建一个字符串对象，栈中的引用指向堆中的字符串对象，然后堆中的字符串对象指向常量池里的字符串。

  ![image-20220715172829860](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151728974.png)



#### 为什么要设置String为不可变对象 ?

1. 安全性：如果很多地方引用了同一个字符串，而且字符串可变的话，此时修改了一下字符串的内容，那这些引用了这个字符串的值都不对了。
2. 节省空间：内容相同的字符串可以指向常量池的同一个空间，从而节省了空间。
3. 线程安全：多个线程修改字符串，都是创建新的字符串，不会造成线程安全问题。



### 10.重写和重载的区别

- 重写：Override

  - 子类继承父类时，可以对父类的方法进行重写。
  - 子类重写的方法必须和父类有相同的方法名称、参数列表。
  - 重写的方法的返回类型要 <= 父类方法的返回类型。
  - 重写方法抛出的异常要 <= 父类方法抛出的异常。
  - 重写方法的访问权限要 >= 父类的访问权限
    - 父类private方法不能被重写。

- 重载：Overload

  - 重载是在一个类中。

  - 重载的方法和原方法的方法名相同，但参数列表必须不同

    ![image-20220715174152658](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151741720.png)

  - 重载的方法可以和原方法有不同的返回值。

    ![image-20220715174306627](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207151743685.png)



### 11.深拷贝和浅拷贝区别

- 引用数据类型：
  - 浅拷贝只是复制引用指针，而没有复制被引用的对象。
  - 深拷贝不仅会复制引用指针，而且会复制一份完整的对象。

#### Object.clone()方法属于浅拷贝还是深拷贝？

浅拷贝。因此如果要使用深拷贝，需要重写clone方法



### 12.Java三大特性

#### (1) 封装

- 类的成员变量私有，通过对外暴露方法来设置和获得变量的值。

#### (2) 继承

- 子类可以继承父类。子类可以通过重写父类的方法来实现父类功能的拓展。
- 类可以实现接口。

#### (3) 多态

- ![img](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207232327866.png)

- 编译看左边，运行看右边。

  - 向上转型：`Person p = new Student();`

    父类引用可以指向子类对象

  - 向下转型：`Student s = (Student)p;`

    子类对象指向父类对象，需要**强制转换**，可能会出现错误

##### 静态绑定

- 对于 static、final、private 方法，编译器能准确的知道该调用哪个方法。

  - 原理：

    ```
    // 被调用的类
    class A{
          public static void hello(){
                  System.out.println("hello!");
          }
    }
    
    // B类中调用A类的静态方法
    public class B {
           public static void main(){
                A.hello(); //调用静态方法
           }
    }
    ```

    1. `A.hello()`会被编译器编译成 invokestatic #13
    2. 然后，JVM会加载类 A
    3. A 类的hello方法的直接地址会被记录到 B 类的常量池中索引为13的常量项。
    4. 之后，调用 A 类的 hello() 方法，就可以直接找到 hello() 方法的字节码

 

##### 动态绑定

```
Person p = new Student();
p.invokeMethod(); // 多态，向上转型
```

- 向上转型后，Person 类型的引用，指向的是子类的类，这时候调用的方法，是子类的方法

  - 原理：

    ```java
    0  new hr.test.Son [13] //在堆中开辟一个Son对象的内存空间，并将对象引用压入操作数栈
    3  dup  
    4  invokespecial #7 [15] // 调用初始化方法来初始化堆中的Son对象 
    7  astore_1 //弹出操作数栈的Son对象引用压入局部变量1中
    8  aload_1 //取出局部变量1中的对象引用压入操作数栈
    9  invokevirtual #15 //调用f1()方法
    12  return
    ```

    

    - JVM 在加载类之后，会在方法区里放一张方法表，这里面存放了当前类和超类的可见方法字节码在内存中的直接地址。

    - 子类重写 (override) 和重载 (overload) 的方法和父类中的方法索引值相同。
      1. 首先，在父类方法表找方法 `f1()`（如果方法子类有，父类没有，那么会编译不通过）
      2. 如果找到，将开始创建在堆中的Son对象的引用压入操作数栈。然后根据 Son 的方法表，找到 `f1() ` 方法的直接地址。

> 有个特殊的例子：
>
> ```java
> class Father{
> 	public void f1(){
> 		System.out.println("father-f1()");
> 	}
>         public void f1(int i){
>                 System.out.println("father-f1()  para-int "+i);
>         }
> }
> //被调用的子类
> class Son extends Father{
> 	public void f1(){ //覆盖父类的方法
> 		System.out.println("Son-f1()");
> 	}
>         public void f1(char c){
>                 System.out.println("Son-s1() para-char "+c);
>         }
> }
> ```
>
> 这时候，调用 `Father f = new Son(); ` 和 `f.f1('c');` 调用的却是Father类型中的f1(int)方法。因为本来 Father 类型没有 Son 类型的 `f1(char c)` 方法，但是 JVM 会把 Father 类型的 `f1(int i)` 认作一个“合适”的方法，然后在调用 `f.f1('c');`  时候，把 c 自动转型成 int 型，所以调用的 Father 的方法。



### 13.Object的方法

1. `getClass()`：获得运行时类型。返回Class对象。

2. `equals()`：

   ```java
   public boolean equals(Object obj) {
           return (this == obj);
       }
   ```

   判断两个对象的地址值是否一样。

3. `clone()`：实现浅拷贝。
4. `toString()`：返回 类名+hashCode的16进制数字。
5. `wait()`：让当前线程进入等待状态
6. `notify()`：唤醒在此对象锁上等待的某个线程（随机的某一个）。
7. `notifyAll()`：唤醒在此对象锁上等待的所有线程。
8. `finalize()`：GC之前调用，在对象二次标记前可以通过这个方法拯救自己。



### 14.接口和抽象类的区别

![image-20220724153814699](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207241538787.png)



### 15.Java反射

1. 反射是动态语言的关键。因为反射机制的存在，Java 成为一种半动态语言。
   - 动态语言：运行时可以改变类的结构。

2. 每个类在加载之后，就会在堆中生成一个Class类型的对象。这个对象保存了类的结构信息。



#### 反射有哪些类？

1. **Class** 类
2. **Field** 类：Java.lang.reflect 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性 值。
3. **Method** 类：Java.lang.reflect 包中的类，表示类的方法，它可以用来获取类中的方法信息或 者执行方法。
4. **Constructor** 类：Java.lang.reflect 包中的类，表示类的构造方法。



#### 获取 Class 的三种方式？

1. `Class.forName("类的全限定名")`

   - 在使用 JDBC 操作数据库时，会加上这么一句，调用这个方法去获取数据库的驱动：`Class.forName("oracle.jdbc.OracleDriver");`

     这个方式会导致类加载，类加载时会执行静态代码块

2. `对象.getClass()`

3. `类.Class`



#### 创建对象的两种方法

1. 使用 Class 对象的 newInstance()

2. 调用 Constructor 对象的 newInstance()

   ```java
   //获取 Person 类的 Class 对象
    Class clazz=Class.forName("reflection.Person");
    //使用.newInstane 方法创建对象
    Person p=(Person) clazz.newInstance();
   //获取构造方法并创建对象
    Constructor c=clazz.getDeclaredConstructor(String.class,
                                               String.class,
                                               int.class);
    //创建对象并设置属性
    Person p1=(Person) c.newInstance("李四","男",20);
   ```

   

#### 有使用过反射吗？

Kafka 收到 Debezium 监控到的 PG 的变更数据后，是一串 Json 数据，其中，有一个 "after": {...} 的字段，里面保存的是新添加的数据，我把该 after 定义成 `HashMap<String, Object>`，然后通过反射的方法去把他转换成一个用于插入数据库的 Entity。

```java
public static AvgDayEntity buildAvgDayEntityFromJson (String body) {

    PostgresJsonEntity postgresJsonEntity = JSON.parseObject(body, PostgresJsonEntity.class);
    AvgDayEntity avgDayEntity = new AvgDayEntity();
    try {
        Field[] fields = avgDayEntity.getClass().getFields();
        HashMap<String, Object> after = postgresJsonEntity.getPayLoad().getAfter();
        for (Field field : fields) {
            if(after.containsKey(field.getName())){
                field.set(avgDayEntity, after.get(field.getName()));
            }
        }

    } catch (IllegalAccessException e) {
        log.error(e.getMessage());
    }

    return avgDayEntity;
}
```



### 16.replace() 和 replaceAll() 的区别

- `replace(char oldChar, char newChar)`: 用newChar替换原String中所有oldChar。
- `replaceAll(String reg, String replacement)`：用replacement代替正则表达式reg匹配的字符串。



### 17.抽象类

#### 抽象类和普通类的区别

1. 抽象类是abstract修饰的类。普通类没有修饰。
2. 抽象类没有具体的实例，而普通类可以生成实例。
3. 包含抽象方法的类一定是抽象类，而普通类不含有抽象方法。

#### 抽象类和接口的区别

1. 抽象类是abstract修饰的类，而接口是interface。
2. 抽象类中可以含有非抽象的方法，而接口中只能含有非抽象的方法。
3. 抽象类可以有构造方法，而接口不能有构造方法。
4. 子类继承抽象类，子类实现接口。
5. 一个类可以实现多个接口，但只能继承于一个抽象类。



### 18.说说面向对象的理解

- 面向对象开发：就是把数据和对数据的操作放在一起，作为一个相互依赖的整体。
  - 封装
  - 继承
  - 多态
- 面向过程开发：以事件为中心，逐步有序运行。



### 19.web中的三大组件分别是？起到了什么作用

1. Servlet
2. Filter
3. Listener



### 20.Java和C++的区别

- Java 编译运行在 JVM 上；而 C++ 在特定的操作系统上编译和运行。
- Java 没有指针；C++ 可以通过指针来直接操作内存空间的值
- Java 的类只能单继承，但类可以实现多个接口；C++ 类可以多继承
- Java 有垃圾自动回收机制；而 C++ 需要关注内存资源的释放。



### 21.什么是 UUID

全局唯一标识符。

- 可以让分布式系统有一个全局唯一的标识符。



## JVM

### 1.JVM的内存区域

1. 



### 2.CAS的ABA问题解决方法

版本号机制



### 3.对象存活判定算法

1. **引用计数法**

   - 缺点：

     - 无法处理循环引用的问题

       ```java
       ReferenceCountingGC objA = new ReferenceCountingGC();
       ReferenceCountingGC objB = new ReferenceCountingGC();
       objA.instance = objB; // objA引用计数器+1
       objB.instance = objA; // objB引用计数器+1
       objA = null; // objA引用计数器仍为1，因为objB仍然在引用objA
       objB = null; // objB引用计数器仍为1，因为objA仍然在引用objB
       // 假设在这行发生GC，objA和objB是否能被回收？
       System.gc(); //不能，objA要回收，必须要等objB不再引用它，而objB要等objA不再引用它；objA和objB引用计数器不为0，无法被回收，但实际上这两个对象已死
       ```

       

     - 存储引用计数器需要额外的空间

2. **可达性分析**

   - 从GC roots出发，根据引用关系向下遍历，遍历路径称为引用链（Reference chain）。如果对象与GC roots之间没有任何引用链相连，则可以回收掉。

   

#### 哪些对象适合做GC roots

1. 虚拟机栈中本地变量表中引用的对象。
2. 方法区中的静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中native方法引用的对象。
   - 比如String常量池中引用的对象。
5. 被synchronized持有的现象。
6. 反应Java虚拟机内部的JM XBean、JVM TI中注册的回调，本地代码缓存等。



### 4.强引用、软引用、弱引用、虚引用

- 强引用 > 软引用 > 弱引用 > 虚引用
  1. 强引用：引用赋值。不会被GC回收的引用
  2. 软引用：还有用，但非必须的对象。内存溢出异常时，GC会对软引用进行第二次回收。如果仍然内存溢出，则抛出内存溢出异常。
  3. 弱引用：非必须的对象，弱引用的对象只存货到下一次GC前。
  4. 虚引用：不是真的引用，也不能通过虚引用获得任何对象。只是为了回收对象时，获得一次通知。

**总结：强引用不会回收，软引用内存不够了回收，若引用下一次GC回收，虚引用不是真的引用，只是为了回收对象时，获得一次通知。**

#### 应用场景







### 5.对象什么时候才算死亡了

**二次标记**

- 第一次标记：可达性分析完以后，不可达的对象会被第一次标记
- 第二次标记：被第一次标记的对象调用`finalize()`方法（如果有finalized方法，或者没有被JVM调用过）， 如果调用finalize方法救活了自己（重新通过referene chain和其他对象关联），则不会被二次标记，否则会被二次标记。



### 6.垃圾收集算法

1. **标记-清除算法**
   - 内存中标记出要回收的对象，然后直接回收
   - 缺点：造成大量内存碎片。
2. **标记-复制算法**
   - 内存中分成区域A和区域B，区域A存放对象，区域B空着
   - 区域A中的对象进行GC完之后，把剩余的对象按序移动到区域B中
   - 优点：解决空间碎片化问题
   - 缺点：空间利用率低
3. **标记-整理算法**
   - 回收完，将对象按序移动到内存空间的一端
   - 缺点：移动对象复杂

4. **分代收集算法**

   - 目前大部分JVM使用，将内存区域分为新生代和老生代。

     - **新生代**：朝生夕灭的对象。

       <u>新生代采用复制算法</u>，因为新生代每次要回收大量对象，所以复制的对象比较少。

       1. 新生代区域划分为Eden区和两块Survivor区（默认比例8：1：1），每次使用Eden区和Survivor区的其中一块区域。
       2. 对象在新生代Eden区进行分配，当Eden区没有足够的空间时，JVM会对Eden进行Minor GC，然后将Eden区和其中一个Survivor区还存活的对象复制到另一个Survivor区。
       3. 对于：
          - 大对象直接存入老年代：需要连续内存空间的Java对象，比如很长的字符串、元素数量很大的数组
          - 长期存活的对象存入老年代：新生代对象每次存活Age+1，默认当Age达到15，就存入老年代。
          - 如果Survivor空间相同年龄的对象大小大于Survivor空间的一半，则大于等于该年龄的对象都放入老年代。

       ![image-20220717182138221](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207181222725.png)

     - **老生代**：不太容易被回收的对象。

       <u>老年代采用标记-复制算法</u>。



### 7.有哪些垃圾回收器

- 新生代
  - Serial
  - ParNew
  - Parallel Scavenge

- 老生代
  - CMS
  - Serial Old
  - Parallel Old
- G1

#### CMS

**多线程标记清除算法**

- 特点：

  1. 追求<u>最短GC停顿时间</u>。
  2. 对处理器资源敏感，
  3. 要在老年代中预留一部分区域供用户使用
     - 如果并发过程中，出现内存不够的情况，就会出现“并发失败”问题
       - 预留方案：冻结用户线程，临时启动Serial Old老年代垃圾回收器。

- 步骤：

  ![image-20220717185330331](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207181222345.png)

  1. **初始标记**：暂停用户线程，<u>标记GC Root能够直接关联到的对象</u>。
  2. **并发标记**：<u>从GC Root开始遍历整个对象图</u>，这时候标记线程和用户线程可以并发执行。
  3. **重新标记**：暂停用户线程，重新标记并发标记阶段因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。
  4. **并发清除**：清除标记的死亡对象，不移动存活对象。垃圾回收线程和用户线程并发执行。

- 缺点：
  1. 无法处理浮动垃圾（本次垃圾回收中，在并发清除期间用户线程新产生的垃圾，需要等待下次垃圾回收时才 能回收。）
  2. 标记-清除算法会产生空间碎片。 

​	

#### G1

面向局部收集，标记-整理

- 特点：
  - 面向局部收集
    - 把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。
  - 垃圾回收算法
    - 整体来看是”标记-整理“算法
    - 局部来看（两个Region之间）是"标记-复制"算法

- 步骤

  ![img](https://img-blog.csdnimg.cn/img_convert/ec618f545687f12c7cfd42e41657e202.webp?x-oss-process=image/format,png)

  - **年轻代GC (Young GC)**：标记-复制算法
  
    - 针对 Eden 区进行收集，把存活的对象复制到 Survivor 区。
    - Survivor 区的数据移动到新 Survivor 区。
    - 如果 Eden 或 Survivor 区空间不足，那么部分对象移动到 Old 区。

  - **并发标记过程 (Concurrent Marking)**

    ![image-20220719102943842](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191029947.png)
  
    1. 初始标记：stop the world，并且标记GC ROOT能直接关联到的对象。
    2. 并发标记：和用户线程并发执行，遍历整个对象图。
    3. 最终标记：处理并发执行阶段变动的对象。
    4. 筛选回收：对各个 Region 区域做一个回收价值和成本的排序，然后筛选回收。把决定回收的 Region 区域内存活的对象移动到空的 Region 区域内，然后清理掉整个决定回收的 Region 区域
  
  - **混合回收(Mixed GC)**：如果老年堆的占比达到设定的阈值
  
    - 回收所有的 Young 和部分 Old (根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，**主要使用标记-复制算法**。
  
  
  
  
  如果上述三个步骤结束，JVM 仍无法正常工作，则触发 Full GC。需要 STOP THE WORLD，然后启动单线程进行垃圾回收。



### 8.Minor GC、Major GC、Full GC

- Minor GC：新生代的GC。
- Major GC：老年代的GC。
- Full GC：收集整个Java堆和方法区的垃圾收集。



### 9.类加载过程

![image-20220719214536901](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207192145997.png)

加载—>连接（验证—>准备—>解析）—>初始化

1. **加载**

   - 通过类的全限定名找到定义类的二进制字节流文件。

   - 将该字节流文件定义的**静态存储结构**转换为方法区上的运行时数据结构。

   - **内存中创建一个代表该类的java.lang.Class对象，作为方法区的这个类各种数据的访问入口。**

     > 方法区 
     >
     > - 逻辑上的区域 
     > - 线程共享 
     > - 存储被虚拟机加载的<u>类型信息</u>、<u>常量</u>、<u>静态变量</u>、即时编译器编译后的<u>代码缓存</u>等数 据。

2. **验证**
   - 验证加载的字节流信息是否符合JVM规范。

3. **准备**

   - 为类中 **static** 变量<u>分配内存</u>到方法区（只是分配内存，真正赋值在初始化阶段）
   - 设置初始值

4. **解析**

   - Java 虚拟机将常量池内的符号引用替换为直接引用。

     > 符号引用：用一组符号来描述所引用的目标，引用的目标不一定是已经加载到虚拟机里的东西。
     >
     > 直接引用：直接引用的对象一定已经加载在虚拟机里了。

   ![image-20220720143553448](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201435538.png)

5. **初始化**

   - 执行 `<clinit>`：给所有类静态变量赋值和执行静态语句块。

     > - <clinit>： 类加载第五步初始化阶段执行，给静态变量赋值和执行static{}语句块。它不需要显式调用父类clinit，因为子类执行clinit时，父类的clinit肯定一定执行完毕。
     >
     >   ![image-20220720144211389](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201442471.png)
     >
     > - <init>：new 对象时候，调用构造器。子类要先加载父类的构造器



### 10.类加载器是做什么的？

用于加载类，即“根据类的全限定名来获取描述该类的二进制字节流”

1. 启动类加载器 Bootstrap Class Loader
2. 拓展类加载器 Extension Class Loader
3. 应用类加载器 Application Class Loader
4. 用户自定义类加载器 User Class Loader



### 11.双亲委派模型

![image-20220720145238233](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201452311.png)

- 一个类加载器在收到类加载请求的时候，会先将请求委托给父类加载器去完成加载。
- 父类加载器如果无法完成加载加载请求，子类才会去尝试完成加载。



### 12.为什么要双亲委派模型？

1. 通过双亲委派模型，java 中的类获得了带有优先级的层级关系。比如 Object 类，最终就是由顶层的启动类加载器去加载，这样 Object 类在程序的各种类加载器环境中都能保证是一个类。
2. 保证 java 的稳定运行。



## 多线程

### 1.进程、线程、协程

- 进程是资源分配的基本单位，线程是任务调度的基本单位。
- 在一个进程里可以创建多个线程，这些线程都拥有各自的<u>计数器</u>、<u>堆栈</u>和<u>局部变量</u>等属性，并且能够访问共享的内存变量。

协程

#### 协程高效在哪？



### 2.notify和notifyAll

等待池：对象调用了线程A的wait方法，线程A就会释放对象的锁，并且进入等待池，在等待池中，不会去竞争对象的锁。

- notify( )：唤醒线程具有随机性。随机选择等待池的一个线程去唤醒。
- notifyAll( )：唤醒等待池中所有线程。



### 3.java的内存模型

![image-20220720154405363](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201544435.png)

1. 主内存
   - 所有变量都存储在主内存中。
2. 工作内存
   - 每个线程都有自己的工作内存。
   - 工作内存中保存该线程所使用的变量的主内存副本。



### 4.Java内存间的交互

![image-20220720154746031](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201547091.png)



## 锁

### 1.死锁

#### 死锁演示代码

```java
public class DeadLockedTest {

    public static void main(String[] args) {
        DeadLock t1 = new DeadLock();
        DeadLock t2 = new DeadLock();
        t1.flag = true;
        new Thread(t1).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t2.flag = false;
        new Thread(t2).start();
    }
}

class DeadLock implements Runnable {

    public static boolean flag = true;

    static Object o1 = new Object();
    static Object o2 = new Object();

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "__flag__" + flag);
        if(flag) {
            synchronized (o1) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                }
            }
        }

        if(!flag) {
            synchronized (o2) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                }
            }
        }
    }
}


```

#### 什么是死锁

多个线程因为争夺资源而陷入僵局，若无外力作用，这些线程会保持僵持状态。



#### 死锁的四个条件

1. **互斥条件**：进程所占有的资源不允许其他进程访问，若其他进程访问该资源，就必须等待，直到占有该资源的进程使用完成后释放。
2. **请求和保持条件**：进程获得一定资源后，又去请求其他资源，而请求的资源被其他进程占用，此请求被阻塞，而占有的资源仍然保持不释放。
3. **不可剥夺条件**：进程已获得的资源，不可被剥夺，只能在使用后自己释放
4. **循环等待条件**：进程发生死锁后，必然存在一个进程--资源的环形链。{P1, P2, ..., Pn}，P1等待P2的资源，P2等待P3的资源.....Pn等待P1的资源。



#### 如何避免死锁

破坏四个必要条件之一即可避免死锁。

1. 破坏请求和保持条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待。
2. 破坏不可剥夺条件：一个进程占有资源后，去请求另一个资源失败后，就放弃占有的资源。
3. 打破循环等待条件：资源有序分配，所有进程按序请求资源。

##### 银行家算法

- 可利用的资源总量
- 每个进程的最大需求资源
- 已分配的资源
- 仍需要的资源

![image-20220712111051281](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207121110411.png)

1. 当一个进程申请资源时，操作系统判断当前资源能否满足
   - 可以满足
     - 判断把进程申请的资源分配给进程后，剩余的资源能否满足进程队列的某个进程执行完毕
       - 能满足，假设回收可以完成执行的进程资源，然后依次判断，直到所有进程都能执行完毕，则安全
       - 不能满足，不安全
   - 不能满足，不安全





### 2.AbstractQueuedSynchronizer（AQS）

- 队列同步器，用于**构建锁**和其他同步组件
- 基于**模板方法**
- 使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作



### 3.锁膨胀机制

无锁—>偏向锁—>轻量级锁—>重量级锁

1. 无锁：

2. 偏向锁：为了在没有线程竞争的情况，减少对轻量级锁的使用。如果锁总是被一个线程获取，那就认为不存在多线程竞争的环境，后续这个线程就可以自动获取锁。

   当虚拟机开启偏向模式后，每当一个锁对象被线程获取，那么虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。持有偏向锁的线程每次进入相关同步块时，虚拟机都不再执行同步操作。

   一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。线程不会主动释放锁，只有遇到其他线程竞争偏向锁时，线程才会释放锁。

3. 轻量级锁：轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。

4. 重量级锁：一个线程获得锁以后，其他等待获取这个锁的线程都会处于阻塞状态。

**锁膨胀过程**：

- 锁对象创建后，默认没有线程竞争。此时，线程A获得锁对象，则锁偏向于线程A，虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。
- 如果此时，出现线程b竞争该锁对象的情况，则会等待全局安全点后，暂停持有偏向锁的线程A，然后检查线程A是否还活着。
  - 如果线程A不处于活动状态，则线程A设置为无锁状态，锁偏向于线程B。
  - 如果线程A仍处于活动状态，则说明产生了锁竞争。升级成为轻量级锁。

- 轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。



### 4.线程安全的实现方式

![image-20220709135312191](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091353254.png)

#### ThreadLocal

![image-20220709135252778](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091352841.png)

#### 定义

线程变量。线程私有的本地变量，它对其他线程是隔离的，其他线程不能访问到该线程的线程本地变量。

线程会维护一个ThreadLocalMap结构，key是ThreadLocalHashCode，即一个ThreadLocal对象，value是本地变量的值，而访问入口就是这个ThreadLocal对象。

#### 使用场景

数据库连接管理。一个线程维护一个连接，线程会保存连接副本，该连接副本就是线程的一个本地变量，其他线程不可以访问该连接副本。

#### 可能出现的问题

内存泄漏问题。线程池中得线程在使用完后，回归到线程池，因为该线程没有被回收掉，所以他引用的ThreadLocal对象也不会被回收掉。这种情况下，如果没有把该线程的ThreadLocal对象remove()掉，那该ThreadLocal对象会一直存在，占用着内存。

解决：线程池的线程任务结束前，手动remove掉ThreadLocal对象。



### 5.synchronized和lock的区别

我们常称synchronized为隐式锁 ，lock为显式锁

1. 实现不同
   - synchronized是JVM层面上的实现
   - Lock是JDK5以后的API接口
2. 



#### 什么时候用synchronized什么时候用ReentrantLock



### 6.volatile和synchronized区别？



### 7.synchronized，lock，AtomicInteger 底层原理







## Java IO模型







## Spring

### 1.bean 的生命周期 



### 2.Spring 中有哪些重要的扩展点 



### 3.BeanFactory 和 ApplicationContext的区别是什么？ 



### 4.BeanFactory 和 FactoryBean有什么区别 



### 5.Spring 的锁



### 6.Spring 的事务



## Nginx

### 1.Nginx的功能

1. 负载均衡
2. 反向代理
3. 动静分离



### 2.负载均衡五种策略

1. **轮询**（默认）

   - 按照请求顺序逐一分配后端服务器
   - 如果后端服务器down掉，可以自动剔除

   ```nginx
   upstream backserver {
       server 192.168.0.14;
       server 192.168.0.15;
   }
   ```

   

2. **带weight的轮询**

   - weight和后端服务器的访问率成正比
   - 适合后端服务器性能不均的情况

   ```nginx
   upstream backserver {
       server 192.168.0.14 weight=3;
       server 192.168.0.15 weight=7;
   }
   ```

   

> 1和2的问题：
>
> - 如果一个用户在一个后端服务器上登录过了，二次请求的时候，被分配到另一个服务器，这时候其登录信息丢失了，就需要重新登录

​	

3. **ip_hash**

   - 通过hash算法，每次把相同的用户定位到同一个后端服务器上去

   ```java
   upstream backserver {
       ip_hash;
       server 192.168.0.14:88;
       server 192.168.0.15:80;
   }
   ```



**第三方策略：**

4. **fair**

   - 按照响应时间来分配后端服务器，响应时间短的优先分配

   ```nginx
   upstream backserver {
       server server1;
       server server2;
       fair;
   }
   ```

   

5. **url_hash**

   - 按照url的结果来分配后端服务器

   ```nginx
   upstream backserver {
       server squid1:3128;
       server squid2:3128;
       hash $request_uri;
       hash_method crc32;
   }
   ```




## RabbitMQ

### 1.RabbitMQ的运行机制

![image-20211213215045356](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191127712.png)



![image-20211213222820600](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191316134.png)

### 2.RabbitMQ的使用场景 (为什么需要消息队列)

1. 异步处理

   ![image-20211213215448208](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191323251.png)

   

2. 应用解耦

   ![image-20211213215610870](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191324618.png)

3. 流量控制（削峰）

   ![image-20211213215754272](https://img-blog.csdnimg.cn/img_convert/eb4287505fb57d652b058460749b0149.png)

### 3.交换机(Exchange)类型

#### 1 Direct Exchange 直连

![image-20211214155932908](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191335774.png)

- **消息路由到那些Bindingkey和Routingkey完全匹配的队列中**。
- 消息的路由键 (routing key) 如果和 Binding 中的 binding key 一致，交换器就将消息发送到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routingkey 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。

#### 2 Fanout Exchange (扇出(广播))

![image-20211214160116199](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207191335635.png)

- **每个发到 fanout 类型交换器的消息都会发送到所有与该 Exchange 绑定的队列上去**。
- fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。

#### 3 Topic Exchange (主题/订阅)

![image-20211214160251228](https://img-blog.csdnimg.cn/img_convert/3c13d7490ec89656bc54203535dc4420.png)

- Topic Exchange 和 Direct Exchange 有点类似，也是将消息路由到 routing key 和 binding key 匹配的队列中去。但是约定 routing key 和 binding key 都用 '.' 分割的



#### 4  Headers 

头交换机类似Topic Exchanger，但是主题交换机是基于消息的路由键（Routing key），而头交换机是基于消息的header数据。

> 消息
>
> - 消息头
>   - routing key
>   - priority：相对于其他消息的优先权
>   - delivery-mode（指出该消息可能需要持久性存储）
>   - ...
> - 消息体



## Kafka

### 1.Kafka的组成机制

![image-20220720163553766](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201635883.png)

#### 基础概念

1. **Consumer Group：** 消费者组。消费者组是逻辑上的一个订阅者
   - 消费者组内每个消费者负责消费不同<u>分区</u>的数据，提高消费能力。
   - 一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组。
2. **Broker：** 
   - 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。

3. Kafka集群将 Record 流存储在称为 topic 的类别中，每个记录由一个键、一个值和一个时间戳组成。

#### 数据存储设计

##### 数据文件

partition的每条message的属性

1. offset：数据在partition里的偏移量
2. messageSize：消息内容data的大小
3. data：message的实际内容

##### 数据文件分段

数据文件分段segment

- partition物理上由多个segment组成，每个segment**大小相等**，且按照**顺序读写**。
- 每个 segment 数据文件以该段中**最小的 offset 命名**，文件扩展名为 .log。
- 使用**二分查找**查找指定offset的message。

##### 数据文件索引

kafka为每个数据文件分段都建立了索引文件，（数据文件名.index）

- 采用稀疏存储的方式，每隔一定字节的数据建立一条索引。

  ![image-20220720170928221](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207201709381.png)





### 2.Kafka和RabbitMQ的区别









### 3.生产者

#### 生产者设计

##### 负载均衡

producer可以通过轮询或者hash的方法，将消息发送到不同的partition上，以实现负载均衡。

##### 批量发送

生产者可以在内存中合并多条消息后，再通过一次请求将消息批量发送给broker，以减少IO的次数，提高吞吐量。

##### 压缩

生产者可以把消息通过GZIP或Snappy格式进行压缩，然后消费者端进行解压减轻网络传输的压力。



#### Kafka如何保证发送消息不丢失、不重复和有序性

##### 不丢失

- 使用带有回调方法的api

- 设置好参数

  - acks：发送成功后，是否等待 broker 返回ack
  - retires：重试次数 
  - retry.backoff.ms：重试间隔

- 1）在**同步模式**的时候，确认机制设置为-1，也就是让消息成功写入leader分区和所有的副本分区。 

  2）在**异步模式**下，如果消息发出去了，但还没有收到确认的时候，缓冲池满了：可以在配置文件中设置成不限制阻塞超时的时间，也就说让生产端一直阻塞，等待缓存区。

##### 不重复

可以让消费端建立去重表。

##### 有序性

生产者发送完一条数据后，要等待 ack 确认后，才能接着发下一条数据。



### 4.消费者

#### 消费者设计

##### 负载均衡

1. RangeAssignor

   ![image-20220720210919573](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207202109736.png)

   按照topic的维度平均分配到不同的消费组里

2. RoundRobinAssignor

   轮询。按顺序一个一个分发给消费组。

3. StickyAssignor

   - 主题分区的分配要尽可能的均匀；
   - 当Rebalance 发生时，尽可能保持上一次的分配方案。



#### Kafka如何保证消费消息不丢失、不重复和有序性

##### 不丢失

- 先消费消息，再更新offset。
- 对于多线程情况，关闭offset自动更新，让消费者自己去维护offset。（Kafka Client）

##### 不重复

- 建立去重表，每次消费判断是否消费过。

##### 有序性

- 



### 5.数据一致性原理

这里介绍的数据一致性主要是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。那么 Kafka 是如何实现的呢？

![img](https://ask.qcloudimg.com/http-save/yehe-6034617/2gm3qrz483.jpeg?imageView2/2/w/1620)

假设分区的副本为3，其中副本0是 Leader，副本1和副本2是 follower，并且在 ISR 列表里面。虽然副本0已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本2，这个很类似于木桶原理。

这样做的原因是还没有被足够多副本复制的消息被认为是“不安全”的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本1为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。

当然，引入了 High Water Mark 机制，会导致 Broker 间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数 replica.lag.time.max.ms 参数配置，它指定了副本在复制消息时可被允许的最大延迟时间。

### 6.ack机制

为保证 producer 发送的数据，能可靠地发送到指定的 topic，topic 的每个 partition 收到 producer 发送的数据后，都需要向 producer 发送 ack（acknowledge 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。



### 7.调优策略



### 8.如何获取topic主题列表

`bin/kafka-topics.sh --list --zookeeper localhost:2181`



### 9.生产者和消费者的命令行是什么？

`bin/kafka-console-producer.sh --broker-list 192.168.43.49:9092 --topic Hello-Kafka`

`bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic Hello-Kafka --from-beginning`



### 10.负载均衡

partition 会均衡分不到不同 broker 上

#### 创建topic的分区分布情况

假设如果一个topic有5个分区，3个副本

1. 随选挑选一个startindex，如图startindex=0，那么startindex=0位置的分区就是leader
2. startindex+1，并按照broker顺序开始生成第一个副本

![up-4b3cfe573c187eac43b664f898edde7c9b7.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62b5209984244c988fc93190facf48c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

#### 如何选出Leader？

![up-59522a3c92dec319889c398e837be2162df.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c42d7394ac949e2bfbd250e9366dd6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

基于`优先副本`，也就是挑选出AR列表中的第一个brokerId上的副本成为leader。

#### 分区自动重平衡

如果开启`auto.leader.rebalance.enable=true`，Controller会开启定时任务，每隔一段时间去轮询brokers，并计算每个broker的分区不平衡率，如果不平衡率超过阈值，则自动进行分区迁移。



## Debezium



## 设计模式篇

### 1.单例模式

也是staic的经典用例

```java
/*
* 饿汉式单例模式
* */
class Bank1 {
    private Bank1() {}

    private static Bank1 instance = new Bank1();

    public static Bank1 getInstance() {
        return instance;
    }
}

/*
* 懒汉式单例模式
* */
class Bank2 {
    private Bank2() {}

    private static Bank2 instance = null;

    public static Bank2 getInstance() {
        if(Objects.isNull(instance)) {
            return new Bank2();
        } else {
            return instance;
        }
    }
}
```

1. **饿汉式**

   优点：线程安全

   缺点：一开始就创建好实例，占用内存。

2. **懒汉式**

   优点：用的时候才创建实例

   缺点：线程不安全

线程安全的懒汉式：

```java
/*
 * 线性安全的懒汉式单例模式
 * */
class Bank3 {
    private Bank3() {}

    private static Bank3 instance = null;

    public static Bank3 getInstance() {
        synchronized (Bank3.class) {
            if(Objects.isNull(instance)) {
                return new Bank3();
            } else {
                return instance;
            }
        }
    }
}
```



#### 双检测机制的单例模式

```java
class Singleton {
    private Singleton() {}

    private volatile static Singleton instance = null;

    public static Singleton getInstance() {
        if(instance  == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

##### 为什么要用双检测机制

因为这样可以即保证能正确的生成单例，又保证了性能。因为只在第一次创建实例的时候加同步锁，之后不用再同步。

##### 单例为什么要用Violatile修饰？

**指令重排：JVM对于代码执行顺序会有优化，因此，代码执行不一定是按照代码编写的顺序。**

创建实例的过程：

1. 开辟内存空间
2. 实例初始化
3. 创建指针指向指定的内存空间

但是，jvm可能会把代码优化成：1——>3——>2

这时候，如果有一个线程在执行1——>3的时候，另一个线程读取instance实例。此时，instance已经指向了一个内存空间，所以就返回了这个instance，这会导致错误。

而violatile实例有两个作用：

- 可见性：violatile修饰的变量对于每个线程都是可见的。
- 有序性：告诉虚拟机，这段代码不需要优化，而是按照代码顺序执行。这样可以避免上述说到的问题。



### 2.工厂模式



### 3. 装饰模式和代理模式区别







## 计网篇

### 1. TCP

TCP提供可靠的，点对点，全双工连接。 

- 可靠的
- 点对点：只能one host to one host
- 全双工：连接后，上层应用层host A和host B可以互相传输data。

#### 三次握手

![image-20220709153545252](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091535317.png)

1. Client 发送报文段给 Server 来请求连接，设置标志位 SYN 为1，sequence number 为随机一个值 x。
2. Server 收到 Client 发来的报文后，设置标志位 SYN 和 ACK 都设置为1，acknowledege number 为 x+1，sequence number 为随机值 y。
3. Client 收到 Server 发来的报文后，检查标志位 ACK 是否1，然后设置回复报文 ACK 为1，seq 为 x+1, acknowledege number 为 y+1。此时，Server 收到报文后，连接建立。

##### (1) 为什么是三次握手？可不可以两次

因为 client 和 server 之间的传输信道是不可靠的，因此，存在消息丢失的可能性。

首先要说，3次握手只是理论上保持可靠传输的最小值。如果只有两次握手，那么可能会出现一种情况：

1. client 发送连接建立请求，结果因为延迟，很晚才到达 server，而在此期间，client 已经取消了连接。
2. server 收到连接请求后，回复确认给 client，并且建立了连接。
3. 然而，此时 client 已经取消了连接，而 server 却建立了连接，并苦苦等待 client 发信息过来，这就造成了 server 的资源浪费。



#### 四次挥手

![image-20220709153558582](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091535686.png)

1. client 主动断开连接，发送 FIN = 1, sequence number = u，表示自己已经停止发送数据。
2. server 收到 client 发来的报文段后，回复 ACK=1 表示确认收到，seq=v，ack=u+1。然后继续发送数据。
3. server 发完报文后，发送 FIN=1，ACK=1，seq=w，ack=u+1，表示自己停止发送数据
4. client 收到报文后，发送 ACK=1，seq=u+1，ack=w+1 给 server。
5. server 说到 ACK 报文后，关闭连接。Client 进行 time_wait 等待（2个最长报文段寿命）后，关闭连接。



##### (1) 为什么要等 2MSL

##### TIME_WAIT

**主动关闭方**在第四次挥手发送 ACK 确认后，需要有一个 TIME_WAIT 等待时间。因为，

1. 主动关闭方无法确认该 ACK 报文对方是是否已经收到。如果该报文段丢失，对方没有收到，而主动关闭方没有进行 TIME_WAIT 等待就关闭了连接，那么对方发送重新发送 FIN 关闭请求时，主动关闭方由于已经关闭了连接而无法收到该报文，这样会导致对方没法正常关闭连接。
2. 防止上一次连接中一些迷路的包发送了过来。

因此，TIME_WAIT 是主动关闭方确保对方已经收到第四次挥手确认报文而存在的。

> TIME_WAIT 一般是 2MSL （Maximum Segment Lifetime）
>
> - RFC 793 文档将 MSL 的时间设置为 120 秒，即两分钟，然而这并不是一个经过严密推断的数值，而是工程上的选择，如果根据服务历史上的经验要求我们改变操作系统的设置，也是没有任何问题的；实际上，较早版本的 Linux 就开始将 `TIME_WAIT` 的等待时间 [`TCP_TIMEWAIT_LEN`](https://github.com/torvalds/linux/blob/bd2463ac7d7ec51d432f23bf0e893fb371a908cd/include/net/tcp.h#L121) 设置成 60 秒，以便更快地复用 TCP 连接资源：

##### CLOSE_WAIT

**被动关闭方**在收到主动关闭方发来的FIN连接关闭请求后，回复ACK报文，之后就进行CLOSE_WAIT状态。等待一段时间后，发送FIN关闭请求给主动关闭方。





### 2.HTTP

#### HTTP1.0

浏览器的每一次请求，都需要和服务器建立一个TCP连接。开销很大。影响服务器的性能。

#### HTTP1.1

1. 持久连接：TCP连接默认不关闭，可以与多个请求共用
2. 管道机制：同一个浏览器和服务器的多次请求可以在同一个TCP连接中，进行通信。
   - http请求头中加入`Connection: keep-alive`来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上`Connection: keep-alive`

3. 分块传输编码：服务器每生成一个数据块，就传输一个数据，用流传输代替缓存传输。
4. 端口是80

- 缺点：
  1. TCP连接中的数据，必须按序到达。服务器只有处理完一个请求后，才可以继续处理下一个请求。这会带来堵塞的问题。

#### HTTPS

HTTPS是HTTP和TCP之间，增加了一条SSL加密层，端口是443。

![image-20220709153614891](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091536947.png)

1. 浏览器发送HTTPS请求给服务器。
2. 服务器收到请求以后，生成公钥和私钥，把公钥和证书一起发给浏览器。
3. 浏览器校验证书后，利用公钥给密钥加密。并且把加密好的密钥发送给服务器。
4. 服务器拿到密钥后，用私钥进行解密。
5. 然后浏览器和服务器之间就建立了一条加密通道，数据都通过这个加密通道进行传输。

##### (1) https的CA机构有什么用



##### (2) CA证书的验证过程



##### (3) https为什么同时使用对称密文和非对称密文

使用不同的场景。

- 非对称加密传输数据：用于交换密钥，安全性更高。

- 对称加密：用于传输数据，速度更快。



##### (4) 为什么不用非对称加密传输数据而是采用对称加密传输数据

> 非对称加密传输数据：用于交换密钥
>
> 对称加密：用于传输数据

对称加密是双方用同一个密钥进行加密和解密

- 计算量小，效率高，速度快
- 而 HTTPS 中传输数据是高频次的行为，需要快。



#### HTTP2

1. 支持多路复用：浏览器和服务器之间可以同时发送多个请求和回复，不要求TCP连接中的数据按序到达。
2. 报头压缩：HTTP2队头部信息进行了信息压缩，减少了头部信息。
3. HTTP2允许服务器未经请求，便向浏览器发送数据。

#### HTTP3

是最新的协议，利用UDP+quic代替TCP+SSL/TLS层。

![image-20220709153635599](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207091536681.png)

##### QUIC



##### 如何设计基于 udp 的可靠传输？



### 3.OSI七层模型



### 4.Session和Cookie

- **Cookie**：
  - Http是无状态协议（HTTP协议**不具备保存之前发送过的请求或响应的功能**），服务器无法得知浏览器的信息。因此，在一个浏览器请求服务器后，会根据浏览器身份生成一个cookie，然后相应给浏览器。之后，浏览器请求的时候，都要带上这个cookie。这样，服务器就可以通过cookie确认身份了。
  - 一般是4k

- **Session**：
  - 服务器保存客户端的信息。访问服务端的客户端信息都会被服务器记录下来。这就是Session。


> 比如gulimall项目中，用户登录成功后，member模块会将后台用户的详细信息返回给auth-server模块，该详细信息序列化成data后，session中保存键值对{userLogin, data}。然后该键值对返回给浏览器，保存为cookie中。



### 5.Session和Token

session和token都是用来保持会话的

- session基于cookie
- token：浏览器登录后，服务器根据用户信息和哈希值，通过密钥进行加密成token，然后直接传给客户端，客户每次请求再携带过来给服务端。服务端直接根据token里面的数据信息进行校验。



### 6.常见状态码

- 200 成功
- 400 错误请求，服务器不知道浏览器的请求语法
- 401 未授权
- 403 forbidden，禁止
- 404 未查到页面
- 500 服务器内部错误



### 7.请求头有什么内容

	1. 请求类型：我们常见的请求类型有Get和Post两种请求，而这个信息在HTTP请求报文中的地一行即请求中就可以得到；
	1. 请求地址：请求地址告诉服务端当前请求来自哪里，例如"/"表示的是服务器根目录，对一个静态网站而言，如果存在index.html

　　　　　　　　则指向该网页；对一个动态网站而已，如果存在index.php则它指向该网页。

3. 请求参数：客户端和服务器的通信最终是要落实到具体数据的传递上来的，所以通过请求报文我们能够获得客户端传递的参数

　　　　　　　　并对其进行处理，通常Get类型参数在请求行、而Post类型参数在消息体中。

4. 请求约束：我们把1、2、3是通信核心要素，那么接下来这些我们可以称其为细节要素。

5. 请求报文



### 8. get, post, put

1. **get**：用于获取和查询资源（select）
2. **post**：用于新增资源（insert），比如表单信息的提取
3. **put**：用于修改资源（update），不会新增资源



### 9.拥塞控制和流量控制



### 10.快重传和超时重传



### 11.常见的网络协议有哪些？



### 12.RPC框架了解吗？







## 操作系统

### 1.用户态和内核态的区别

![image-20220724162448073](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207241624178.png)

1. 内核态
   - 从图上我们可以看出来通过**系统调用**将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种**特殊的软件程序**，特殊在哪儿呢？**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

2. 用户态
   - 用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**



从用户态到内核态切换可以通过三种方式：

1. 系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
2. 异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。
3. 外设中断：当外设完成用户的请求时，会向CPU发送中断信号。

### 2.进程和线程

#### 进程

- 程序资源分配的基本单位
- = **线程** + **内存（逻辑内存，用于内存寻址）** + **文件/网络句柄**
  - 文件/网络句柄：所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。

#### 线程

- 程序调度的基本单位
- = 栈 + PC 程序计数器 + TLS 本地存储



### 3.Select poll 和 epoll 的区别





### 4.虚拟内存作用？ 内存分页的作用？





### 5. 缺页异常的介绍





### 6.OOM问题和 StackOverFlow的区别





### 7.如何手动销毁一个进程？

`exit()`

`kill 进程id`



##### 敲出这行命令之后，进程如何响应这个指令的呢

**SIGKILL：**用户终止进程执行信号。



### 8.进程间通信有几种方法

- 每个进程有自己的用户地址空间，任何一个进程的全局变量在另一个进程中都是看不见的。

- 所以进程间交换数据必须通过内核

- **进程间通信：进程1把数据从用户空间中拷贝到内核缓冲区，进程2再从内核缓冲区内把数据拷走。**

  ![image-20220725103127196](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207251031273.png)

#### (1) 管道/匿名管道

![image-20220725103944045](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207251039114.png)

- 半双工：数据同一时候只能从一方流向另一方。如果需要双方通信的话，需要建立两个管道。
- 管道对于两端进程来说，就是一种文件系统。只存在于内存中。
- 管道实质就是个缓冲区，可以看作一个循环队列。

匿名管道：只能提供给有血缘关系的进程。



#### (2) 有名管道 (FIFO)

- 有名管道**名字存在于文件系统中，内容存在内存中**，可以供**无**血缘关系的进程之间使用。
- 进程可以通过访问有名管道保存的路径，进行通信。
- 遵循 FIFO



#### (3) 信号 Signal

- 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
- 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
- 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

> **Linux系统中常用信号：**
>
> 1. **SIGHUP：**用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
> 2. **SIGINT：**程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
> 3. **SIGQUIT：**程序退出信号。程序运行过程中，按`Ctrl+\\`键将产生该信号。
> 4. **SIGBUS和SIGSEGV：**进程访问非法地址。
> 5. **SIGFPE：**运算中出现致命错误，如除零操作、数据溢出等。
> 6. **SIGKILL：**用户终止进程执行信号。shell下执行`kill -9`发送该信号。
>    - 面试题：执行 `kill -9` 后发生了什么？
> 7. **SIGTERM：**结束进程信号。shell下执行`kill 进程pid`发送该信号。
> 8. **SIGALRM：**定时器信号。
> 9. **SIGCLD：**子进程退出信号。如果其父进程没有忽略该信号也没 有处理该信号，则子进程退出后将形成僵尸进程



##### 信号生命周期和处理流程

1. 信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
2. 操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
3. 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括**临时寄存器数据，当前程序位置以及当前CPU的状态**）、转而执行中断服务程序，执行完成后在恢复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。



#### (4) Message 消息队列

- 消息队列存放于内核中。一种消息链表。
- 不一定要FIFO，可以随机查询。
- 允许一个或多个进程向它写入与读取消息。



#### (5) 共享内存

- 多个进程可以可以直接读写同一块内存空间。



#### (6) 信号量 semaphore

![img](https://upload-images.jianshu.io/upload_images/1281379-376528c40d03717e.png?imageMogr2/auto-orient/strip|imageView2/2/w/635/format/webp)

- 信号量是个计数器，用于进程间同步



#### (7) 套接字

![image-20220725112829427](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207251128502.png)





### 9.pcb有什么用





### 10.组合shell命令，把一些进程一起删掉



### 11.fork()作用



### 12.进程调度策略有哪几种？

1.





## 算法

### KMP

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201052782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

##### 算法思想

利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置

接下来我们自己来发现j的移动规律：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201107203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

如图：C和B不匹配了，我们要把j移动到哪？应该是第2位。为什么？因为前面AB相同：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201112929.png)



##### 算法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201148169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201203201234972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjYyMjIwMA==,size_16,color_FFFFFF,t_70)

- 关键是求出每个位置处j对应的k，有了k，就知道当某位置处的j和原字符串不匹配时，要将j移动几个位置：next[]
- 当`p[j]==p[k]`时，`next[j+1]==next[j]+1`，所以`k=next[k]`
  - 现在j所在的位置是C，C不匹配，移动到B的位置，D不匹配移动到C的位置

```java
public static int[] getNext(String pattern) {

    char[] p = pattern.toCharArray();
    int[] next = new int[p.length];
    next[0] = -1; // 如果 pattern 第一位不匹配，i指针要后移，所以初始化为-1
    int j = 0;
    int k = -1;

    while (j < p.length - 1) {
       if (k == -1 || p[j] == p[k]) {
           next[++j] = ++k;
       } else {
           k = next[k];
       }
    }

    return next;
}
```



### 雪花算法









### 并查集

- 用一个一维数组维护一片森林

- parent数组维护每个节点的父节点

  ![img](https://img-blog.csdnimg.cn/img_convert/62fafe0883d4665cef6cf5d3b6b659b9.png)

- rank数组记录每个节点的高

  ![img](https://img-blog.csdnimg.cn/img_convert/99c317f34c43ec0d48ae803af0b16320.png)



### 拓扑排序

![img](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202207232020572.jpeg)

1. 删除入度为 0 的节点 —> 1
2. 再删除入度为 0 的节点 —> 2
3. ....
4. 删除入度为 0 的节点 —> 5

{1, 2, 3, 4, 5}



## Linux

### 1.常用指令

#### (1) 查看占用端口

lsof -i:80

#### (2) apt

apt-get install

apt-get remove

apt-get purge：会把配置文件也删除

#### (3) grep

- 用于查找文件中符合条件的字符串

#### (4) |

- 管道符

A | B

A 的输出作为 B 的输入。

#### (5) find

- 查找**指定目录**下的文件
- 如果不设置参数，则是查找当前目录下

#### (6) locate

去保存文档名称的数据库内查找符合条件的文档或目录

#### (7) whereis

- 该指令会在特定目录中查找符合条件的文件。
- 只能用于查找二进制文件、源代码文件和 man 手册页，一般文件的定位需使用locate命令。

#### (8) touch

1. 把已存在的文件时间标签更新为当前系统时间
2. 创建新的空文件

#### (9) 



### 2.如果你在Linux系统删除一个文件失败，如何解决？





### 3.被哪个进程占用之类的信息你觉得会存在哪里？





### 4.如果一个服务端口被占用，如何查看？



### 5.Linux 按 ctrl + c 中断的原理



### 6.



## Git

### 1.常用指令



### 2.git怎么创建分支



### 3.git怎么从缓存区拿出来



























