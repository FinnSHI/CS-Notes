# 快乐面试题

2、Java集合框架了解哪些？总体架构？常用的一些类的特性说一说 

  3、ArrayList和LinkedList（说出场景，后指出添加元素相关的操作时不说场景的情况下，说不定谁的效率高的） 

  4、源码层面他俩的元素具体是怎么存的？（说的很浅，应该不太满意） 

  5、 ArrayList和LinkedList是否线程安全？有哪些安全的？（阿里一面也问到了，当时没说全，下来看了，刚好派上用场） 

  6、Map类了解吗？HashMap在put一个值的时候的具体过程？ 

  7、因为漏说了最开始会先判断是否扩容，问是否知道扩容机制？（这里答的很深，从源码一行行说的，面试官表示不错） 

  8、HashMap是否线程安全？有哪些安全的实现？（有遗漏的点面试官都会指出来） 

  9、ConCurrentMap在jdk1.7和1.8后分别是怎么实现的？ 

  10、分段锁是用的什么锁？ 

  11、Java中的锁你了解多少？ 

  12、volatile和synchronized区别？ 

  13、synchronized用法？锁的膨胀机制 

  14、除了 synchronized还有哪些锁？ 

  15、什么时候用synchronized什么时候用ReentrantLock？（没答好）

2，map(hashmap，hashtable，synchronizedmap，concurrenthashmap)
3，synchronized，volatile，ReentrantLock
4，mysql索引
5，redis的持久化，aof和rdb
6，aof重写
7，http和https的区别



## Java篇

### 1. ArrayList和LinkedList 的区别？

1. 底层实现不同：他们的底层实现不一样。ArrayList 底层实现是数组，而 LinkedList 底层是双向循环链表。
2. 适用场景不同：
   - ArrayList适合快速读取元素的场景。然而对于元素的插入和删除，需要大量的移动其他的元素。
   - 而LinkedList适合插入和删除频繁的场景。但是对于指定位置元素的查询，需要对链表进行遍历。LRU的实现。
3. 空间占用不同：
   - ArrayList底层是数组，而LinkedList除了要保存节点元素外，还要保存pre和next指针，因此更占空间。



### 2. HashMap

#### 为什么扩容是原来的2倍

- HashMap是用hash值来处理冲突的，因此，在存放每个entry时，要先利用它的hash值来计算出在底层数组相应的位置，计算公式是：hash & (n-1)。

- 因此，扩容成原来的2倍，能够保证 n-1 是个前面为0，后面都是1的值，这样 hash & (n-1) 就会保留hash后面部分的值，而舍去前面部分的值。这样的好处是：

  - 保证计算得到的位置在 capacity 内

  - hash & (n-1) = hash % n

    

#### 开放地址法

1. 二次探测
   - 比如：(hash+2i) % n
2. 线性探测
   - 冲突了就线性找



#### 扩容机制

HashMap底层是数组+链表或者红黑树

JDK7，数组初始容量为16，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

JDK8，HashMap是懒加载，数组初始容量为0，当put第一个元素时，创建初始容量16的数组，负载因子是0.75，当元素超过16*0.75时，就会触发扩容。

- 当链表元素 > 8且哈希表长度 > 64时，则会转变成红黑树
- 当空间不足时，扩容成原来的2倍。



#### HashMap & ConcurrentHashMap

- HashMap是线程不安全的
- ConcurrentHashMap是线程安全的，并且继承了ReentrantLock类。它将底层大数组划分成若干的segment，并且对每个segment进行上锁。再匹配到要存入的segment后，用synchronized进行上锁，然后再进行对应的操作。



#### HashMap & HashTable

- HashMap是线程不安全的，并且key和value都可以为null。它是Map接口的实现类，效率较高。
- HashTable是线程安全的，它的方法都是synchronized修饰的，key和value都不能为null。



#### SynchronizedMap

java.util.concurrent.synchronizedMap(new Map<>()；用来给一个map对象上锁。



#### HashMap是否线程安全？有哪些安全的实现

不是线程安全的。

- HashTable：给每个方法都上了synchronized锁来实现线程安全。性能较差。

- java.util.concurrent.ConcurrentHashMap，通过ReentrantLock来实现线程安全的。
- Collections.synchronizedHashMap(new HashMap<>());，也是给传入的HashMap对象加synchronzied锁实现



### 3. ConcurrentHashMap

#### JDK7

- JDK 7 的ConcurrentHashMap采用的是分段锁的方法。分段锁对象Segment继承于ReentrantLock类
- 分段锁Segment对象里面保存的是HashEntry数组，该数组用来存放元素。
- HashEntry中的value和next指针都是viotile类型。

分段锁Segment

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301101484.png)

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301100394.png)



存放元素的 HashEntry数组

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301103109.png)



- put

  ![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301141682.png)

  1. 调用ReentrantLock的tryLock方法，尝试获取对象锁。
     - 如果没有获取到对象锁，则调用scanAndLockForPut方法去尝试获取对象锁
  2. 拿到锁以后，那么就执行类似HashMap的put方法。
  3. 但是插入元素是用的头插法。



**scanAndLockForPut**：实现了类似自旋锁的功能。会设置一个重试次数，然后不断尝试tryLock()，并且这个重试次数会自增。

- 如果要存放的对应HashEntry位置为空，那么就创建新的节点。
- 如果key相同，那就不断尝试tryLock获取锁，如果重试次数大于最大重试次数，那就调用Lock()方法去获取锁。
- 如果lock()方法也不能获取锁，那么线程堵塞等待。
- 如果循环期间，HashEntry被改动过，那么重试次数置为-1，重新开始重试

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301344592.png)



#### JDK8

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301529186.png)



- put（CAS + synchronized）

  ```java
      final V putVal(K key, V value, boolean onlyIfAbsent) {
          // 1.如果key或者value为null，抛出异常
          if (key == null || value == null) throw new NullPointerException();
          // 2.获取hash值
          int hash = spread(key.hashCode());
          int binCount = 0;
          for (Node<K,V>[] tab = table;;) {
              Node<K,V> f; int n, i, fh;
              // 3.table为空，初始化
              if (tab == null || (n = tab.length) == 0)
                  tab = initTable();
              // 4.如果对应的位置没有元素，则调用乐观锁CAS方法插入元素
              else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                  if (casTabAt(tab, i, null,
                               new Node<K,V>(hash, key, value, null)))
                      break;                   // no lock when adding to empty bin
              }
              // 5.如果对应位置上的元素hash值为-1，MOVED，说明有线程正在进行扩容，则帮忙一起扩容
              else if ((fh = f.hash) == MOVED)
                  tab = helpTransfer(tab, f);
              else {
                  V oldVal = null;
                  // 6.否则，加synchronzied锁
                  synchronized (f) {
                      if (tabAt(tab, i) == f) {
                          if (fh >= 0) {
                              binCount = 1;
                              // 7.1 对于链表结构，进行循环查找，找到相应的值，并且替换value
                              for (Node<K,V> e = f;; ++binCount) {
                                  K ek;
                                  if (e.hash == hash &&
                                      ((ek = e.key) == key ||
                                       (ek != null && key.equals(ek)))) {
                                      oldVal = e.val;
                                      if (!onlyIfAbsent)
                                          e.val = value;
                                      break;
                                  }
                                  Node<K,V> pred = e;
                                  if ((e = e.next) == null) {
                                      pred.next = new Node<K,V>(hash, key,
                                                                value, null);
                                      break;
                                  }
                              }
                          }
                          // 7.2 如果位置上节点是红黑树节点，则插入到树中
                          else if (f instanceof TreeBin) {
                              Node<K,V> p;
                              binCount = 2;
                              if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                             value)) != null) {
                                  oldVal = p.val;
                                  if (!onlyIfAbsent)
                                      p.val = value;
                              }
                          }
                      }
                  }
                  // 8.如果链表上的节点大于8，则尝试扩容
                  if (binCount != 0) {
                      if (binCount >= TREEIFY_THRESHOLD)
                          treeifyBin(tab, i);
                      if (oldVal != null)
                          return oldVal;
                      break;
                  }
              }
          }
          addCount(1L, binCount);
          return null;
      }
  ```

  



### 4. String, StringBuffer, StringBuilder

1. String是不可变的，每次对String的修改，都是在常量池中生成一个新的String，然后将指针指向这个新的String。

2. StringBuffer和StringBuilder都是可变字符串。

   - StringBuffer是线程安全的，每次append()都会上锁，同步锁是new出来的StringBuilder对象。
   - StringBuilder是线程不安全的，大多数情况下StringBuilder要比StringBuffer快。

3. JDK5之前，String连加会被优化成StringBuffer，JDK5之后，优化成StringBuilder。

   ```java
   public String concatString(String s1, String s2, String s3) {
   	return s1 + s2 + s3;
   }
   ```

   ```java
   public String concatString(String s1, String s2, String s3) {
       StringBuffer sb = new StringBuffer();
       sb.append(s1);
       sb.append(s2);
       sb.append(s3);
       return sb.toString();
   }
   ```

   

### 5. equals 和 == 的区别

1. ==：
   - 基本数据类型：==比较的是值是否相等。
   - 引用数据类型：==比较的是地址值是否相等。
2. equals：
   - 比较的是对象的地址是否相等。Object类中，equals的定义就是比较两个Object对象的地址值是否一样。
   - 但是String，Date，File和包装类中的equals方法被重写过，比较的是两者的内容是否相等。



### 6.为什么要重写 hashcode 和 equals 方法

在HashMap存储自定义的类的时候，需要重写hashcode和equals方法。

- 比如，存放id都为1的两个对象k1和k2。如果不重写hashcode和equals方法，在hashmap中put完k1后，如果get(k2)，会得到null，尽管他们的id相同。
- 因为自定义类没有重写hashcode，他们默认会以地址值作为自己的hash值，所以，k1和k2会放在不一样的位置。因此要重写。
- 如果没有重写equals方法，自定义类会使用Object类的equals方法，比较k1和k2的地址值是否相同，而k1和k2的地址值是不同的，但是id相同，因此要重写equals方法。



### 7.请你解释为什么会出现4.0-3.6=0.40000001这种现象？

《Java核心技术 卷I》：

因为二进制无法精确地表示十进制的数。在进行浮点型4.0-3.6的时候，需要先从十进制转变成二进制，再进行计算，这里面就会产生一些误差。这就跟十进制没法表示出1/3一样。

如果想计算过程中没有差错，应该用BigDecimal类。



### 8.

### 9.重写和重载的区别

### 10.深拷贝和浅拷贝区别

### 11.Java三大特性

### 12.Object的方法

1. `getClass()`：获得运行时类型。返回Class对象。

2. `equals()`：

   ```java
   public boolean equals(Object obj) {
           return (this == obj);
       }
   ```

   判断两个对象的地址值是否一样。

3. `clone()`：实现浅拷贝。
4. `toString()`：返回 类名+hashCode的16进制数字。
5. `wait()`：让当前线程进入等待状态
6. `notify()`：唤醒在此对象锁上等待的某个线程（随机的某一个）。
7. `notifyAll()`：唤醒在此对象锁上等待的所有线程。
8. `finalize()`：GC之前调用，在对象二次标记前可以通过这个方法拯救自己。



### 13.ArrayList和LinkedList是否线程安全？有哪些安全的？

不是线程安全的。

**ArrayList**：比如现在有线程A和线程B同时想要在0的位置add元素，此时ArrayList的size为0。

- A线程在0位置添加元素后，在size++之前，因为一些原因被阻塞。
- B线程读取到size仍为0，则在0位置添加元素后，size++。
- A线程再让size++。
- 最终，ArrayList里只有1一个元素，size却为2。

**LinkedList**：比如现在有线程A和线程B同时想要在链表末尾add元素。

- 线程A获取到链表的last节点，并且指定l=last，此时，A因为一些原因被堵塞。

- 线程B正常地在链表末尾添加新的节点。
- 线程A恢复运行，在l后面添加新元素。
- 这时候，线程B添加的新节点实际上已经访问不到了。

**有哪些线程安全的**：

- 方法Collections.synchronizedList(new **LinkedList**<>());
- ConcurrentLinkedQueue, java.util.concurrent.CopyOnWriteArrayList
- Vector



### 14.反射

1. 反射是动态语言的关键。每个类在加载之后，就会在堆中生成一个Class类型的对象。这个对象保存了类的结构信息。



### 15.replace() 和 replaceAll() 的区别

- replace(char oldChar, char newChar): 用newChar替换原String中所有oldChar。
- replaceAll(String reg, String replacement)：用replacement代替正则表达式reg匹配的字符串。



### 16.抽象类

#### 抽象类和普通类的区别

1. 抽象类是abstract修饰的类。普通类没有修饰。
2. 抽象类没有具体的实例，而普通类可以生成实例。
3. 包含抽象方法的类一定是抽象类，而普通类不含有抽象方法。

#### 抽象类和接口的区别

1. 抽象类是abstract修饰的类，而接口是interface。
2. 抽象类中可以含有非抽象的方法，而接口中只能含有非抽象的方法。
3. 抽象类可以有构造方法，而接口不能有构造方法。
4. 子类继承抽象类，子类实现接口。
5. 一个类可以实现多个接口，但只能继承于一个抽象类。



## 并发篇

### 1.死锁

#### 死锁演示代码

```java
public class DeadLockedTest {

    public static void main(String[] args) {
        DeadLock t1 = new DeadLock();
        DeadLock t2 = new DeadLock();
        t1.flag = true;
        new Thread(t1).start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        t2.flag = false;
        new Thread(t2).start();
    }
}

class DeadLock implements Runnable {

    public static boolean flag = true;

    static Object o1 = new Object();
    static Object o2 = new Object();

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "__flag__" + flag);
        if(flag) {
            synchronized (o1) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                }
            }
        }

        if(!flag) {
            synchronized (o2) {
                try {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o2);
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + "拿到了锁" + o1);
                }
            }
        }
    }
}


```

#### 死锁的四个条件



#### 如何避免死锁



### 2.AbstractQueuedSynchronizer（AQS）



### 3.进程和线程



### 4.notify和notifyAll

等待池：对象调用了线程A的wait方法，线程A就会释放对象的锁，并且进入等待池，在等待池中，不会去竞争对象的锁。

- notify( )：唤醒线程具有随机性。随机选择等待池的一个线程去唤醒。
- notifyAll( )：唤醒等待池中所有线程。



### 5.锁膨胀机制

无锁—>偏向锁—>轻量级锁—>重量级锁

1. 无锁：

2. 偏向锁：为了在没有线程竞争的情况，减少对轻量级锁的使用。如果锁总是被一个线程获取，那就认为不存在多线程竞争的环境，后续这个线程就可以自动获取锁。

   当虚拟机开启偏向模式后，每当一个锁对象被线程获取，那么虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。持有偏向锁的线程每次进入相关同步块时，虚拟机都不再执行同步操作。

   一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。线程不会主动释放锁，只有遇到其他线程竞争偏向锁时，线程才会释放锁。

3. 轻量级锁：轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。

4. 重量级锁：一个线程获得锁以后，其他等待获取这个锁的线程都会处于阻塞状态。

**锁膨胀过程**：

- 锁对象创建后，默认没有线程竞争。此时，线程A获得锁对象，则锁偏向于线程A，虚拟机会通过CAS操作在对象的Mark Word里记录获取锁的线程ID。
- 如果此时，出现线程b竞争该锁对象的情况，则会等待全局安全点后，暂停持有偏向锁的线程A，然后检查线程A是否还活着。
  - 如果线程A不处于活动状态，则线程A设置为无锁状态，锁偏向于线程B。
  - 如果线程A仍处于活动状态，则说明产生了锁竞争。升级成为轻量级锁。

- 轻量级锁是为了减少重量级锁带来的性能消耗。线程即将进入同步块时，如果此同步对象没有被锁定，那么虚拟机就会在线程的栈空间中，生成一个锁记录Lock Record空间，然后虚拟机使用CAS尝试把对象的Mark Word指向线程栈空间中的Lock Record。如果成功，则线程获得锁。轻量级锁允许两个线程竞争。但是如果两个以上的线程竞争，那么就必须膨胀为重量级锁。



## Spring

### bean的生命周期 



### Spring中有哪些重要的扩展点 



### BeanFactory和ApplicationContext的区别是什么？ 



### BeanFactory和FactoryBean有什么区别 







## 设计模式篇

### 1.单例模式

也是staic的经典用例

```java
/*
* 饿汉式单例模式
* */
class Bank1 {
    private Bank1() {}

    private static Bank1 instance = new Bank1();

    public static Bank1 getInstance() {
        return instance;
    }
}

/*
* 懒汉式单例模式
* */
class Bank2 {
    private Bank2() {}

    private static Bank2 instance = null;

    public static Bank2 getInstance() {
        if(Objects.isNull(instance)) {
            return new Bank2();
        } else {
            return instance;
        }
    }
}
```

1. **饿汉式**

   优点：线程安全

   缺点：一开始就创建好实例，占用内存。

2. **懒汉式**

   优点：用的时候才创建实例

   缺点：线程不安全

线程安全的懒汉式：

```java
/*
 * 线性安全的懒汉式单例模式
 * */
class Bank3 {
    private Bank3() {}

    private static Bank3 instance = null;

    public static Bank3 getInstance() {
        synchronized (Bank3.class) {
            if(Objects.isNull(instance)) {
                return new Bank3();
            } else {
                return instance;
            }
        }
    }
}
```



### 2.双检测机制的单例模式

```java
class Singleton {
    private Singleton() {}

    private volatile static Singleton instance = null;

    public static Singleton getInstance() {
        if(instance  == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 为什么要用双检测机制

因为这样可以即保证能正确的生成单例，又保证了性能。因为只在第一次创建实例的时候加同步锁，之后不用再同步。

#### 单例为什么要用Violatile修饰？

**指令重排：JVM对于代码执行顺序会有优化，因此，代码执行不一定是按照代码编写的顺序。**

创建实例的过程：

1. 开辟内存空间
2. 实例初始化
3. 创建指针指向指定的内存空间

但是，jvm可能会把代码优化成：1——>3——>2

这时候，如果有一个线程在执行1——>3的时候，另一个线程读取instance实例。此时，instance已经指向了一个内存空间，所以就返回了这个instance，这会导致错误。

而violatile实例有两个作用：

- 可见性：violatile修饰的变量对于每个线程都是可见的。
- 有序性：告诉虚拟机，这段代码不需要优化，而是按照代码顺序执行。这样可以避免上述说到的问题。





### 3. 装饰模式和代理模式区别



## 计网篇

### 1. TCP

TCP提供可靠的，点对点，全双工连接。 

- 可靠的
- 点对点：只能one host to one host
- 全双工：连接后，上层应用层host A和host B可以互相传输data。

#### 三次握手

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203281502867.png)

1. Client发送报文段给Server来请求连接，设置标志位syn为1，sequence number为随机一个值x。
2. Server收到Client发来的报文后，设置标志位SYN和ACK都设置为1，acknowledege number为x+1，sequence number为随机值y
3. Client收到Server发来的报文后，检查标志位ACK是否1，然后设置回复报文ACK为1，seq为 x+1, acknowledege number为 y+1。此时，Server收到报文后，连接建立。

#### 为什么是三次握手？可不可以两次

因为client和server之间的传输信道是不可靠的，因此，存在消息丢失的可能性。

首先要说，3次握手只是理论上保持可靠传输的最小值。如果只有两次握手，那么可能会出现一种情况：

1. client发送连接建立请求，结果因为延迟，很晚才到达server，而在此期间，client已经取消了连接。
2. server收到连接请求后，回复确认给client，并且建立了连接。
3. 然而，此时client已经取消了连接，而server却建立了连接，并苦苦等待client发信息过来，这就造成了server的资源浪费。



#### 四次挥手

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203281500101.jpeg)

1. client主动断开连接，发送FIN=1, sequence number = u，表示自己已经停止发送数据。
2. server收到client发来的报文段后，回复ACK=1表示确认收到，seq=k，ack=u+1。然后继续发送数据。
3. server发完报文后，发送FIN=1，ACK=1，seq=w，ack=u+1，表示自己停止发送数据
4. client收到报文后，发送ACK=1，seq=u+1，ack=w+1给server。
5. server说到ACK报文后，关闭连接。Client 进行time_wait等待（2个最长报文段寿命）后，关闭连接。

#### TIME_WAIT

**主动关闭方**在第四次挥手发送ACK确认后，需要有一个TIME_WAIT等待时间。因为，

1. 主动关闭方无法确认该ACK报文对方是是否已经收到。如果该报文段丢失，对方没有收到，而主动关闭方没有进行TIME_WAIT等待就关闭了连接，那么对方发送重新发送FIN关闭请求时，主动关闭方由于已经关闭了连接而无法收到该报文，这样会导致对方没法正常关闭连接。
2. 防止上一次连接中一些迷路的包发送了过来。

因此，TIME_WAIT是主动关闭方确保对方已经收到第四次挥手确认报文而存在的。

> TIME_WAIT一般是2MSL （Maximum Segment Lifetime）
>
> - RFC 793 文档将 MSL 的时间设置为 120 秒，即两分钟，然而这并不是一个经过严密推断的数值，而是工程上的选择，如果根据服务历史上的经验要求我们改变操作系统的设置，也是没有任何问题的；实际上，较早版本的 Linux 就开始将 `TIME_WAIT` 的等待时间 [`TCP_TIMEWAIT_LEN`](https://github.com/torvalds/linux/blob/bd2463ac7d7ec51d432f23bf0e893fb371a908cd/include/net/tcp.h#L121) 设置成 60 秒，以便更快地复用 TCP 连接资源：

#### CLOSE_WAIT

**被动关闭方**在收到主动关闭方发来的FIN连接关闭请求后，回复ACK报文，之后就进行CLOSE_WAIT状态。等待一段时间后，发送FIN关闭请求给主动关闭方。



### 2.HTTP

#### HTTP1.0

浏览器的每一次请求，都需要和服务器建立一个TCP连接。开销很大。影响服务器的性能。

#### HTTP1.1

1. 持久连接：TCP连接默认不关闭，可以与多个请求共用
2. 管道机制：同一个浏览器和服务器的多次请求可以在同一个TCP连接中，进行通信。
   - http请求头中加入`Connection: keep-alive`来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上`Connection: keep-alive`

3. 分块传输编码：服务器每生成一个数据块，就传输一个数据，用流传输代替缓存传输。
4. 端口是80

- 缺点：
  1. TCP连接中的数据，必须按序到达。服务器只有处理完一个请求后，才可以继续处理下一个请求。这会带来堵塞的问题。

#### HTTP2

1. 支持多路复用：浏览器和服务器之间可以同时发送多个请求和回复，不要求TCP连接中的数据按序到达。
2. 报头压缩：HTTP2队头部信息进行了信息压缩，减少了头部信息。
3. HTTP2允许服务器未经请求，便向浏览器发送数据。

#### HTTPS

HTTPS是HTTP和TCP之间，增加了一条SSL加密层，端口是443。

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301643235.png)

1. 浏览器发送HTTPS请求给服务器。
2. 服务器收到请求以后，生成公钥和私钥，把公钥和证书一起发给浏览器。
3. 浏览器校验证书后，利用公钥给密钥加密。并且把加密好的密钥发送给服务器。
4. 服务器拿到密钥后，用私钥进行解密。
5. 然后浏览器和服务器之间就建立了一条加密通道，数据都通过这个加密通道进行传输。

#### HTTP3

是最新的协议，利用UDP+quic代替TCP+SSL/TLS层。

![image-20220330165039046](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202203301650124.png)

### 3.OSI七层模型



### 4.Session和Cookie

- Cookie：Http是无状态协议，服务器无法得知浏览器的信息。因此，在一个浏览器请求服务器后，会根据浏览器身份生成一个cookie，然后相应给浏览器。之后，浏览器请求的时候，都要带上这个cookie。这样，服务器就可以通过cookie确认身份了。
- Session：服务器保存客户端的信息。访问服务端的客户端信息都会被服务器记录下来。这就是Session。



### 5.状态码

- 200 成功
- 400 错误请求，服务器不知道浏览器的请求语法
- 401 未授权
- 403 forbidden，禁止
- 404 未查到页面
- 500 服务器内部错误



### 6.请求头有什么内容

	1. 请求类型：我们常见的请求类型有Get和Post两种请求，而这个信息在HTTP请求报文中的地一行即请求中就可以得到；
	1. 请求地址：请求地址告诉服务端当前请求来自哪里，例如"/"表示的是服务器根目录，对一个静态网站而言，如果存在index.html

　　　　　　　　则指向该网页；对一个动态网站而已，如果存在index.php则它指向该网页。

3. 请求参数：客户端和服务器的通信最终是要落实到具体数据的传递上来的，所以通过请求报文我们能够获得客户端传递的参数

　　　　　　　　并对其进行处理，通常Get类型参数在请求行、而Post类型参数在消息体中。

4. 请求约束：我们把1、2、3是通信核心要素，那么接下来这些我们可以称其为细节要素。

5. 请求报文
