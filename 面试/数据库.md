# 数据库

## MySQL

### Mysql存储特点

- Mysql存储数据以**数据页**为最小单位。
- 在同一个数据页中，数据按照**主键**，**连续**存储；如果没有主键，则按照Mysql维护的 **ROW_ID** 来连续存储。
- 数据页和数据页之间以双向链表关联。
- 数据和数据时间之间以单向链表关联。



### 左连接和右连接

比如A表为左表，B表为右表

1. 左连接
   - left join是以左表为准的，是以A表的记录为基础的。
     换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID)。B表记录不足的地方均为NULL。
2. 右连接
   - 和left join相反





### drop、delete、truncate的区别

1. delete
   - DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。DELETE操作不会减少表或索引所占用的空间。
   - delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。

2. truncate
   - TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。
   - 并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
   - 当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，

3.   drop
   - drop语句删除表结构及所有数据，并将表所占用的空间全部释放。
   - 不能回滚，不会触发触发器。



## 索引

### B+树

B+树每个节点指向数据库里的一个page，每个page一般是16k大小。B+树非叶节点只保存键值，叶节点保存数据。

优点：

- 支持外键和auto_Increment。
- 支持事务操作。
- 支持从灾难中恢复数据（从Bin-log日志等）。
- 适用于需要经常更新的表。比如在高并发操作下的表。

#### InnoDB的索引

1. 索引可以增加查询速度，使无序的数据变得有序
2. InnoDB索引底层数据结构是B+树

#### 为什么不用红黑树或者B树？

1. 为什么不用红黑树
   - 红黑树是一种"二叉搜索树"，每个node节点只能保存一对key，value
   - B或B+树是一种”多路搜索树“，每个node节点可以保存多个数据
   - 因此，相比较而言，B或者B+树比红黑树高度更低，高度更低就意味着检索速度更快。
2. 为什么不用B树
   - B+树相比较B树，有两个优势
     - B+树的非叶子节点，只保存索引，而不保存数据，因此B+树比B树更加矮壮。这就意味着，B+树检索速度会更快
     - B+树叶子节点是一个有序双向链表，遍历查询更方便。



### 索引原则





### 什么是回表

回表会基于**<u>非主键索引的查询需要多扫描一棵索引树</u>**。即当通过非主键索引找到索引列值以外的字段时，就会回表。

- 因为非主键索引建立的B+树叶子节点的数据表保存的是索引列值和主键。（聚簇索引保存的是主键和其他所有列值）

- 所以，如果要查询索引值以外的值时，先要通过非主键索引找到相应的主键值，再通过主键值去**<u>聚簇索引B+树</u>**找到相应的数据行，再读取出要查询的数据。

- 比如，MySQL采用非主键索引name来作为索引，那么底层B+树存放的是name列值和主键id。如果此时用一下sql查询

  ```sql
  select * from student where name = "James"
  ```

  那么MySQL只能进行查询到name列值和相应的id，而其他的列值就必须通过这个id，再去聚簇索引保存的B+树，找到相应的数据并读取。这就是回表。

#### 怎样避免回表

覆盖索引。比如如果要查orderId和orderName，那就以这两个字段作为联合索引。这样orderId和orderName就作为数据保存在B+树的叶子节点上了，就不需要回表操作了。

### 覆盖索引

将被查询的字段，建立到联合索引里去

**场景1：全表count查询优化**

![img](https://finn-typora.oss-cn-shanghai.aliyuncs.com/pic/202204141640649.jpeg)

原表为：
user(PK id, name, sex)；

直接：
select count(name) from user;
不能利用索引覆盖。

添加索引：
alter table user add key(name);
就能够利用索引覆盖提效。



### 最左前缀原则/最左匹配原则

当Mysql建立联合索引时，会采取最左匹配优先原则。

在最左匹配原则中，有如下说明：

1. 最左前缀匹配原则，非常重要的原则，mysql会根据联合索引一直向右匹配直到遇到范围查询 (>、<、between、like) 就停止匹配
   - 比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
   - 因为B+树的叶子节点中，数据页和数据页是按照联合索引第一个值来排序的，然后才是第二个，然后才是第三个。
2. = 和 in 可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成查询效率最高的形式，也就是匹配联合索引的形式。



1. **匹配最左边的列**
   
   - 比如联合索引是(a1, a2, a3)
     - 那么(a1)， (a1, a2)，(a1, a3) 都会触启用联合索引(a1, a2, a3)的查询，到联合索引(a1, a2, a3)树中去查询。（a2, a1）等也行
     - 而（a2），（a2，a3）等都不会触发联合索引(a1, a2, a3)的查询。
   
2. **.匹配列前缀**

   - 如果id是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。

   ```
   select * from staffs where id like 'A%';//前缀都是排好序的，使用的都是联合索引
   select * from staffs where id like '%A%';//全表查询
   select * from staffs where id like '%A';//全表查询
   ```



3. **遇到范围**

   - 遇到范围查询 (>、<、between、like) 就会停止匹配。

   - 原因：

     - 联合索引底层B+树是通过最左边的列来构建的。

       ![在这里插入图片描述](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203141624045.png)

       可以看到，左边的列是有序的，为1，1，2，2，3，3。左边列相同，才会根据后一个列值排序。所以，遇到范围查询是没办法按序去查询的，只能退化到线性查询。

> by the way， 联合索引最多只能包含16列



### 索引下推

当有联合索引 (name, age) 时，如果我们执行以下语句：

```sql
select * from user_info where name="王%" and age=20
```

- 在mysql 5.6之前，该查询首先会通过name去联合索引(name, age)树里查询，找到多条符合name="王%"的数据，然后触发回表操作，去table里找到符合条件的数据，整个过程需要回表多次。

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202204021435220.png)



- mysql 5.6 之后，有了索引下推。在索引内部就会判断age是否等于20，这样在(name, age)联合索引树中只会找到一个数据，然后拿着id回表找到数据。整个过程只需要回表一次。

![img](https://raw.githubusercontent.com/FinnSHI/PictureBed/main/imgs/202204021439902.png)




## InnoDB事务

### 什么是事务？

事务是一组操作，这一组操作要么同时成功，要么同时失败。



### 事务的特性

ACID

- **A**tomicity：原子性
- **C**onsistency：一致性
- **I**solation：隔离性
- **D**uration：持久性

#### 原子性

事务的操作要么成功，要么失败。

- MYSQL InnoDB的底层是通过 undo log 来实现的。undo log 记载着变化前的数据。所以，一旦事务操作失败，数据库就会根据 undo log 的值回滚成原来的数据。

#### 一致性

一致性是事务的目的。我们对数据库操作，就是要保证数据的一致性。一旦事务操作失败，就应该回滚到原先的数据。

#### 隔离性

事务与事务之间是隔离的，互不影响的。

- 数据库一共有四种隔离级别。
-  底层是用锁来实现的

#### 持久性

事务一旦commit，那么对数据库的改变应该是永久的。就是说，数据应该被持久化在硬盘上。

- 持久性是通过 redo log 来实现的。数据库在对数据进行修改的时，先是查询找到相应要修改的数据页，然后把数据页写入到内存中，进行修改。

  为了防止mysql 挂掉，所以 mysql 会维护一个 redo log，记载本次在内存中对数据的修改。如果 MySQL 挂掉，我们也可以通过这个 redo log 来恢复数据。



### 数据库锁

InnoDB下，锁分为行锁和表锁。

- 行锁：当 sql 命中索引节点时，上的就是行锁
  - 读锁：读锁可以被多个事务共享。多个事务可以同时读取一个资源，但是不允许其他事务修改这个资源。
  - 写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。
- 表锁：当 sql 没有命中索引节点时，那么锁的是整个索引树，此时是表锁。

![img](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203151018281.jpeg)



## 数据库并发问题

1. 脏写：事务A修改了事务B未提交的数据。
2. 脏读：事务A读取了事务B更新，但未提交的数据。之后事务B对数据库进行了回滚，那么事务A读到的就是无效的数据。
3. 不可重复读：事务A读取的数据，该数据之后被事务B修改并提交。事务A再次读取这个数据时，发生这个数据和之前读到的不一样。
4. 幻读：事务A读取一张表时，事务B在这个表中插入了几行新的数据。当事务A再次读这个表时，发现表和之前的表不一样。



### 四种隔离级别

1. READ UNCOMMITTED: 允许事务读取更新了但未提交的数据。脏读、不可重复读、幻读的问题均存在。
2. READ COMMITTED: 允许事务读取已经被其他事务提交了的数据。可以避免脏读，但是不可重复读、幻读问题不可避免。
3. REPETABLE READ: 事务读取一个字段时，不允许其他事务对该字段进行修改。可以避免脏读，不可重复读，但幻读问题不可避免。
4. SERILIZATION: 事务读取一个表时，不允许其他事务对这个表进行操作。可以避免脏读，不可重复读，幻读问题，但是性能低。



### READ UNCOMMITTED原理

![img](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203151124467.jpeg)

- 读不加锁，写加锁。会带来脏读问题。脏读问题不可接受。
- 但是如果给读加锁，那么数据库在进行更新时，就不可读了，会带来性能上的问题
- 解决办法：MVCC（多版本并发控制 Multi-Version Concurrency Control）



### MVCC





## MySQL主从同步
