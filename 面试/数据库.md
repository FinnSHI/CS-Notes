# 数据库

## MySQL

### Mysql存储特点

- Mysql存储数据以**数据页**为最小单位。
- 在同一个数据页中，数据按照**主键**，**连续**存储；如果没有主键，则按照Mysql维护的 **ROW_ID** 来连续存储。
- 数据页和数据页之间以双向链表关联。
- 数据和数据时间之间以单向链表关联。

1. - - 





## 索引

### B+树

B+树每个节点指向数据库里的一个page，每个page一般是16k大小。B+树非叶节点只保存键值，叶节点保存数据。

优点：

- 支持外键和auto_Increment。
- 支持事务操作。
- 支持从灾难中恢复数据（从Bin-log日志等）。
- 适用于需要经常更新的表。比如在高并发操作下的表。

#### InnoDB的索引

1. 索引可以增加查询速度，使无序的数据变得有序
2. InnoDB索引底层数据结构是B+树

#### 为什么不用红黑树或者B树？

1. 为什么不用红黑树
   - 红黑树是一种"二叉搜索树"，每个node节点只能保存一对key，value
   - B或B+树是一种”多路搜索树“，每个node节点可以保存多个数据
   - 因此，相比较而言，B或者B+树比红黑树高度更低，高度更低就意味着检索速度更快。
2. 为什么不用B树
   - B+树相比较B树，有两个优势
     - B+树的非叶子节点，只保存索引，而不保存数据，因此B+树比B树更加矮壮。这就意味着，B+树检索速度会更快
     - B+树叶子节点是一个有序双向链表，遍历查询更方便。



### 索引原则

1. 索引的值必须唯一
2. 索引并非越多越好
   - 因为索引也会占据空间
   - 比如MySQL会给每个索引建立B+树，索引太多就是建立多个B+树，占据空间。
3. 当索引的值很长时，可以将值的前缀作为索引



### 什么是回表

当通过非主键索引找到索引列值以外的字段时，就会回表。

- 因为非主键索引建立的B+树叶子节点的数据表保存的是索引列值和主键。（聚簇索引保存的是主键和其他所有列值）

- 所以，如果要查询索引值以外的值时，先要通过非主键索引找到相应的主键值，再通过主键值去聚簇索引B+树找到相应的数据行，再读取出要查询的数据。

- 比如，MySQL采用非主键索引name来作为索引，那么底层B+树存放的是name列值和主键id。如果此时用一下sql查询

  ```sql
  select * from student where name = "James"
  ```

  那么MySQL只能进行查询到name列值和相应的id，而其他的列值就必须通过这个id，再去聚簇索引保存的B+树，找到相应的数据并读取。这就是回表。

### 怎样避免回表

覆盖索引。比如如果要查orderId和orderName，那就以这两个字段作为联合索引。这样orderId和orderName就作为数据保存在B+树的叶子节点上了，就不需要回表操作了。

### 最左匹配原则/最左前缀原则

当Mysql建立联合索引时，会采取最左匹配优先原则

1. **匹配最左边的列**
   - 比如联合索引是(a1, a2, a3)
     - 那么(a1)， (a1, a2)，(a1, a3) 都会触启用联合索引(a1, a2, a3)的查询。（a2, a1）等也行
     - 而（a2），（a2，a3）等都不会触发联合索引(a1, a2, a3)的查询。

2. **.匹配列前缀**

   - 如果id是字符型，那么前缀匹配用的是索引，中坠和后缀用的是全表扫描。

   ```
   select * from staffs where id like 'A%';//前缀都是排好序的，使用的都是联合索引
   select * from staffs where id like '%A%';//全表查询
   select * from staffs where id like '%A';//全表查询
   ```



3. **遇到范围**

   - 遇到范围查询 (>、<、between、like) 就会停止匹配。

   - 原因：

     - 联合索引底层B+树是通过最左边的列来构建的。

       ![在这里插入图片描述](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203141624045.png)

       可以看到，左边的列是有序的，为1，1，2，2，3，3。左边列相同，才会根据后一个列值排序。所以，遇到范围查询是没办法按序去查询的，只能退化到线性查询。



> by the way， 联合索引最多只能包含16列




## InnoDB事务

### 什么是事务？

事务是一组操作，这一组操作要么同时成功，要么同时失败。



### 事务的特性

ACID

- **A**tomicity：原子性
- **C**onsistency：一致性
- **I**solation：隔离性
- **D**uration：持久性

#### 原子性

事务的操作要么成功，要么失败。

- MYSQL InnoDB的底层是通过 undo log 来实现的。undo log 记载着变化前的数据。所以，一旦事务操作失败，数据库就会根据 undo log 的值回滚成原来的数据。

#### 一致性

一致性是事务的目的。我们对数据库操作，就是要保证数据的一致性。一旦事务操作失败，就应该回滚到原先的数据。

#### 隔离性

事务与事务之间是隔离的，互不影响的。

- 数据库一共有四种隔离级别。
-  底层是用锁来实现的

#### 持久性

事务一旦commit，那么对数据库的改变应该是永久的。就是说，数据应该被持久化在硬盘上。

- 持久性是通过 redo log 来实现的。数据库在对数据进行修改的时，先是查询找到相应要修改的数据页，然后把数据页写入到内存中，进行修改。

  为了防止mysql 挂掉，所以 mysql 会维护一个 redo log，记载本次在内存中对数据的修改。如果 MySQL 挂掉，我们也可以通过这个 redo log 来恢复数据。



### 数据库锁

InnoDB下，锁分为行锁和表锁。

- 行锁：当 sql 命中索引节点时，上的就是行锁
  - 读锁：读锁可以被多个事务共享。多个事务可以同时读取一个资源，但是不允许其他事务修改这个资源。
  - 写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。
- 表锁：当 sql 没有命中索引节点时，那么锁的是整个索引树，此时是表锁。

![img](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203151018281.jpeg)



## 数据库并发问题

1. 脏读：事务A读取了事务B更新，但未提交的数据。之后事务B对数据库进行了回滚，那么事务A读到的就是无效的数据。
2. 不可重复读：事务A读取的数据，该数据之后被事务B修改并提交。事务A再次读取这个数据时，发生这个数据和之前读到的不一样。
3. 幻读：事务A读取一张表时，事务B在这个表中插入了几行新的数据。当事务A再次读这个表时，发现表和之前的表不一样。



### 四种隔离级别

1. READ UNCOMMITTED: 允许事务读取更新了但未提交的数据。脏读、不可重复读、幻读的问题均存在。
2. READ COMMITTED: 允许事务读取已经被其他事务提交了的数据。可以避免脏读，但是不可重复读、幻读问题不可避免。
3. REPETABLE READ: 事务读取一个字段时，不允许其他事务对该字段进行修改。可以避免脏读，不可重复读，但幻读问题不可避免。
4. SERILIZATION: 事务读取一个表时，不允许其他事务对这个表进行操作。可以避免脏读，不可重复读，幻读问题，但是性能低。



### READ UNCOMMITTED原理

![img](https://gitee.com/FinnSHI/PicBed/raw/master/imgs/202203151124467.jpeg)

- 读不加锁，写加锁。会带来脏读问题。脏读问题不可接受。
- 但是如果给读加锁，那么数据库在进行更新时，就不可读了，会带来性能上的问题
- 解决办法：MVCC（多版本并发控制 Multi-Version Concurrency Control）



### MVCC

